<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Génération de la Population</title>
    <style>
        :root {
            --primary-color: #0077b6;
            --primary-hover: #023e8a;
            --secondary-color: #f4f4f4;
            --border-color: #ddd;
            --text-dark: #333;
            --danger-color: #d00000;
            --success-color: #28a745;
            --job-color: #c97b0a;
            --save-color: #1e6e0f;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--secondary-color);
            margin: 0;
            padding: 20px;
            color: var(--text-dark);
            line-height: 1.6;
        }
        .container {
            display: grid;
            grid-template-columns: 500px 1fr;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }
        #config-panel, #results-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3, h4 { color: var(--primary-color); }
        h2 { border-bottom: 1px solid var(--border-color); padding-bottom: 8px; margin-top: 0; }
        h3 { margin-top: 25px; }
        h4 { font-size: 1.1em; border-bottom: none; margin: 15px 0 10px; }
        h5 { font-size: 1.05em; color: #333; margin: 10px 0 5px 0;}
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; }
        input, select, textarea {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            box-sizing: border-box;
        }
        textarea { min-height: 80px; resize: vertical; }
        input[readonly] { background-color: #e9ecef; font-weight: bold; }
        
        button {
            background: var(--primary-color);
            color: white;
            cursor: pointer;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 1em;
            font-weight: 500;
        }
        button:hover { background: var(--primary-hover); }
        button:disabled { background: #cccccc; cursor: not-allowed; }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .button-group button {
            flex-grow: 1;
        }

        .race-management-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        #save-races-db-btn {
            background-color: var(--save-color);
        }
        
        .race-card {
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--primary-color);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        .race-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .race-card-header h4 { margin: 0; border: none; padding: 0; }
        .race-card-header .delete-race-btn {
            background-color: var(--danger-color);
            color: white;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }
        .grid-2-col { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        #total-percentage { font-weight: bold; text-align: right; margin-top: 10px; padding: 8px; border-radius: 4px; }
        
        #validation-checklist { margin-bottom: 20px; }
        #validation-checklist p { font-weight: bold; }
        #validation-checklist ul { list-style: none; padding: 0; margin-top: 10px; }
        #validation-checklist li {
            padding: 8px; margin-bottom: 5px; border-radius: 4px;
            transition: all 0.3s ease;
            border-left: 5px solid;
            font-size: 0.9em;
        }
        #validation-checklist li.valid {
            color: #155724;
            background-color: #d4edda;
            border-color: var(--success-color);
        }
        #validation-checklist li.invalid {
            color: #721c24;
            background-color: #f8d7da;
            border-color: var(--danger-color);
        }
        #validation-checklist li::before {
            font-weight: bold;
            margin-right: 10px;
        }
        #validation-checklist li.valid::before { content: '✔'; }
        #validation-checklist li.invalid::before { content: '❌'; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: none; justify-content: center;
            align-items: center; z-index: 1000;
        }
        .modal-content {
            background: white; padding: 25px; border-radius: 8px; width: 90%;
            max-width: 1600px; height: 90vh; display: flex; flex-direction: column;
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; }
        .modal-close { font-size: 2rem; cursor: pointer; font-weight: bold; }
        .modal-body { 
            overflow: hidden;
            margin-top: 15px;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            flex-grow: 1;
        }
        #population-display, #history-log {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #history-log-content {
            overflow-y: auto;
            padding: 5px;
            flex-grow: 1;
        }
        #history-log-content p {
            font-size: 0.9em;
            margin: 0 0 8px 0;
            border-bottom: 1px dashed #eee;
            padding-bottom: 8px;
        }
        #real-time-stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        #real-time-stats h4 {
            margin: 0 0 10px 0;
        }
        #real-time-stats ul {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 0.95em;
        }
        #real-time-stats li {
            margin-bottom: 5px;
        }
        #real-time-stats ul ul {
            padding-left: 20px;
            margin-top: 5px;
        }
        .tab-nav {
            display: flex;
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        .tab-button {
            padding: 10px 15px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 1em;
            color: var(--text-dark);
        }
        .tab-button.active {
            font-weight: bold;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            margin-bottom: -2px;
        }
        
        /* --- SCROLL FIX STARTS HERE --- */
        .tab-panels {
            flex-grow: 1; /* Allows the panel container to take up available vertical space */
            display: flex; /* Makes it a flex container for its single active child panel */
            overflow: hidden; /* Clips any overflow, the scrolling will be handled by a deeper child */
        }
        .tab-panel {
            display: none; /* Inactive panels are hidden */
            flex-direction: column; /* All panels are now flex columns */
            flex-grow: 1; /* The active panel will grow to fill its container (.tab-panels) */
            padding-top: 15px;
        }
        .tab-panel.active {
            display: flex; /* Active panels are shown as flex containers */
        }
        .tab-panel-content {
            flex-grow: 1; /* The content div itself grows to fill the remaining space */
            overflow-y: auto; /* This element is the one that will scroll if content overflows */
            padding-right: 10px; /* Add some padding to avoid scrollbar overlapping content */
        }
        /* --- SCROLL FIX ENDS HERE --- */

        details { border: 1px solid #eee; border-radius: 4px; margin-bottom: 8px; }
        summary { padding: 10px; cursor: pointer; font-weight: bold; background: #f8f9fa; }
        
        .family-tree ul {
            list-style: none;
            padding-left: 25px;
            border-left: 1px solid #ccc;
        }
        .family-tree li {
            padding: 4px 0;
            line-height: 1.4;
            position: relative;
        }
        .family-tree li::before {
            content: '';
            position: absolute;
            top: 12px;
            left: -15px;
            width: 15px;
            height: 1px;
            background-color: #ccc;
        }

        .person-job {
            font-style: italic;
            color: var(--job-color);
        }
        .dead {
            text-decoration: line-through;
            opacity: 0.6;
        }
        .maiden-name, .origin-info {
            font-style: italic;
            color: #666;
            font-size: 0.9em;
        }
        .family-history {
            background-color: #f0f3f5;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 5px 15px 15px 15px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        .family-history h5 {
            margin: 10px 0 5px 0;
            color: var(--primary-color);
            font-size: 1em;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .family-history ul {
            padding-left: 20px;
            margin: 5px 0;
            list-style-type: disc;
        }
        .family-history li {
             margin-bottom: 4px;
        }
        .family-history .open-history-modal-btn {
            font-size: 0.8em;
            padding: 3px 8px;
            margin-top: 10px;
            width: 100%;
            background-color: #6c757d;
        }
        .family-history-moved p {
            margin: 10px 0 5px 0;
            line-height: 1.5;
        }
        .evolution-section {
             margin-bottom: 20px;
        }
        .evolution-section ul {
            list-style: none;
            padding: 0;
        }
         .evolution-section li {
            padding: 5px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
        }
        .evolution-section li:last-child {
            border-bottom: none;
        }
         .job-name {
            font-weight: 500;
        }
         .job-count {
            font-weight: bold;
        }

    </style>
</head>
<body>
    <div class="container">
       <div id="config-panel">
            <h2>Configuration de la Simulation</h2>
            <div class="control-group grid-2-col">
                <div>
                    <label>Année Actuelle</label>
                    <input type="text" id="current-year" value="Année 0" readonly>
                </div>
                <div>
                    <label>Familles Fondatrices (Total)</label>
                    <input type="text" id="total-families" value="0" readonly>
                </div>
            </div>
            <h3>Gestion des Races</h3>
            <div class="control-group">
                <label for="preset-race-select">Charger une race pré-définie</label>
                <div style="display: flex; gap: 10px;">
                    <select id="preset-race-select">
                        <option value="">-- Choisir une race --</option>
                    </select>
                    <button id="load-preset-race-btn" style="width: auto; flex-shrink: 0;">Charger</button>
                </div>
            </div>
            <div class="race-management-buttons">
                <button id="add-race-btn">+ Ajouter une Race (Manuelle)</button>
                <button id="save-races-db-btn">Sauvegarder les Races</button>
            </div>
            <div id="race-list"></div>
            <p id="total-percentage">Total des pourcentages : 0%</p>
        </div>
        <div id="results-panel">
            <h2>Lancement</h2>
            <div id="validation-checklist">
                <p>Pour lancer la simulation, veuillez remplir les conditions suivantes :</p>
                <ul>
                    <li id="check-percentage" class="invalid"></li>
                    <li id="check-families" class="invalid"></li>
                    <li id="check-races" class="invalid"></li>
                </ul>
            </div>
            <div class="button-group">
                <button id="start-simulation-btn" disabled>Lancer la Simulation (G0)</button>
                <button id="view-results-btn" disabled>Voir le Résultat</button>
            </div>
        </div>
    </div>
    
    <template id="race-card-template"><div class="race-card"><div class="race-card-header"><h4>Nouvelle Race</h4><button class="delete-race-btn">Supprimer</button></div><div class="control-group"><label>Nom de la Race</label><input type="text" class="race-name" placeholder="Ex: Humain"></div><div class="grid-2-col"><div class="control-group"><label>Espérance de vie</label><input type="number" class="race-lifespan" value="80" min="1"></div><div class="control-group"><label>Âge adulte</label><input type="number" class="race-adultage" value="18" min="1"></div></div><div class="grid-2-col"><div class="control-group"><label>Prénoms Masculins (séparés par virgule)</label><textarea class="race-firstnames-m" placeholder="Arthur, Lancelot, ..."></textarea></div><div class="control-group"><label>Prénoms Féminins (séparés par virgule)</label><textarea class="race-firstnames-f" placeholder="Guenièvre, Morgane, ..."></textarea></div></div><div class="control-group"><label>Noms de famille (séparés par virgule)</label><textarea class="race-lastnames" placeholder="Pendragon, De Leonis, ..."></textarea></div><div class="control-group"><label>Pourcentage de présence (%)</label><input type="number" class="race-percentage" value="0" min="0" max="100"></div></div></template>

    <div id="population-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h2 id="population-modal-title">Population de la Région</h2><span class="modal-close">&times;</span></div>
            <div id="population-modal-body" class="modal-body">
                <div id="population-display">
                    <div class="tab-nav"></div>
                    <div class="tab-panels"></div>
                </div>
                <div id="history-log">
                    <h3>Historique des Événements</h3>
                    <div id="history-log-content"></div>
                    <div id="real-time-stats">
                        <h4>Statistiques</h4>
                        <ul>
                            <li id="stats-births">Naissances : 0</li>
                            <li id="stats-deaths">Décès : 0</li>
                            <li id="stats-marriages">Mariages : 0</li>
                            <li id="stats-migrations">Migrations : 0
                                <ul>
                                    <li id="stats-mig-marriage">↳ par mariage : 0</li>
                                    <li id="stats-mig-opportunity">↳ par opportunité : 0</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="history-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 800px; height: 80vh;">
            <div class="modal-header">
                <h2 id="history-modal-title">Historique de la famille</h2>
                <span id="history-modal-close" class="modal-close">&times;</span>
            </div>
            <div id="history-modal-body" style="overflow-y: auto; padding: 15px;">
                </div>
        </div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- MISE EN CACHE DES ÉLÉMENTS DU DOM ---
        const totalFamiliesInput = document.getElementById('total-families');
        const addRaceBtn = document.getElementById('add-race-btn');
        const raceListDiv = document.getElementById('race-list');
        const raceCardTemplate = document.getElementById('race-card-template');
        const totalPercentageP = document.getElementById('total-percentage');
        const startSimBtn = document.getElementById('start-simulation-btn');
        const viewResultsBtn = document.getElementById('view-results-btn');
        const populationModal = document.getElementById('population-modal');
        const historyModal = document.getElementById('history-modal');
        const checkPercentEl = document.getElementById('check-percentage');
        const checkFamiliesEl = document.getElementById('check-families');
        const checkRacesEl = document.getElementById('check-races');
        const saveRacesBtn = document.getElementById('save-races-db-btn');
        const currentYearInput = document.getElementById('current-year');
        const presetRaceSelect = document.getElementById('preset-race-select');
        const loadPresetRaceBtn = document.getElementById('load-preset-race-btn');

        const statsBirthsEl = document.getElementById('stats-births');
        const statsDeathsEl = document.getElementById('stats-deaths');
        const statsMarriagesEl = document.getElementById('stats-marriages');
        const statsMigrationsEl = document.getElementById('stats-migrations');
        const statsMigMarriageEl = document.getElementById('stats-mig-marriage');
        const statsMigOpportunityEl = document.getElementById('stats-mig-opportunity');

        // --- VARIABLES DE SIMULATION ---
        let allRegions = {};
        let simulation = {
            year: 0, population: [], families: {},
            races: {}, eventLog: []
        };
        
        // --- DONNÉES DE CONFIGURATION ---

        // MODIFICATION 1: On initialise un objet vide. Il sera rempli avec les données chargées.
        let PRESET_RACES = {};

        const guildData = {
            'Guilde des Artisans': {
                required_buildings: ['Forge', 'Menuisier / Charpentier', 'Tanneur / Maroquinier', 'Tisserand / Tailleur'],
                min_buildings: 2,
                min_pop: 100,
                master_role: 'Maître de la Guilde des Artisans',
                member_role: 'Artisan de Guilde',
            },
            'Guilde des Combattants': {
                required_buildings: ['Caserne / Garde', 'Murailles', 'Arène / Colisée'],
                min_buildings: 1,
                min_pop: 150,
                master_role: 'Maître de la Guilde des Combattants',
                member_role: 'Combattant de Guilde',
            },
            'Guilde des Érudits': {
                required_buildings: ['Bibliothèque / Scriptorium', 'Atelier de mage', "Échoppe d'alchimiste", 'Observatoire'],
                min_buildings: 1,
                min_pop: 250,
                master_role: 'Maître de la Guilde des Érudits',
                member_role: 'Érudit de Guilde',
            }
        };

        const jobData = {
            base_jobs: {
                'Hameau': [{ role: 'Chef(fe) de hameau', tier: 2, unique: true, quantity: 1 }],
                'Village': [{ role: 'Maire du village', tier: 2, unique: true, quantity: 1, promotes_from: ['Garde champêtre'] }, { role: 'Garde champêtre', tier: 3, quantity: 2 }],
                'Ville': [{ role: 'Maire', tier: 1, unique: true, quantity: 1, promotes_from: ['Capitaine de la garde', 'Magistrat'] }, { role: 'Capitaine de la garde', tier: 2, unique: true, quantity: 1, promotes_from: ['Sergent'], guild_affiliation: 'Guilde des Combattants' }, { role: 'Magistrat', tier: 2, unique: true, quantity: 1, promotes_from: ['Greffier'] }, { role: 'Greffier', tier: 3, quantity: 1 }],
                'Capitale': [{ role: 'Dirigeant(e)', tier: 1, unique: true, scope: 'region', quantity: 1 }, { role: 'Général(e) de la garde', tier: 1, unique: true, quantity: 1, promotes_from: ['Capitaine de la garde'] }, { role: 'Archiviste royal', tier: 2, unique: true, quantity: 1, promotes_from: ['Maître Bibliothécaire'], guild_affiliation: 'Guilde des Érudits' }, { role: 'Maître espion', tier: 2, unique: true, quantity: 1 }]
            },
            building_jobs: {
                'Taverne / Auberge': [
                    { role: 'Tavernier/ère', tier: 3, unique: true, quantity: 1 }, 
                    { role: 'Serveur/euse', tier: 4, dynamic_quantity_per_pop: 40 },
                    { role: 'Videur', tier: 4, dynamic_quantity_per_pop: 150 }
                ],
                'Forge': [
                    { role: 'Maître Forgeron', tier: 2, unique: true, quantity: 1, promotes_from: ['Apprenti(e) Forgeron'], guild_affiliation: 'Guilde des Artisans' }, 
                    { role: 'Apprenti(e) Forgeron', tier: 4, master: 'Maître Forgeron', quantity: 2, guild_source: 'Guilde des Artisans' }
                ],
                'Marché central': [
                    { role: 'Maître du marché', tier: 3, unique: true, quantity: 1 }, 
                    { role: 'Vendeur de stand', tier: 4, dynamic_quantity_per_pop: 30 }
                ],
                'Écuries': [
                    { role: 'Maître d\'écurie', tier: 3, unique: true, quantity: 1, promotes_from: ['Palefrenier'] }, 
                    { role: 'Palefrenier', tier: 4, quantity: 4 }
                ],
                'Boulangerie': [
                    { role: 'Maître Boulanger', tier: 3, unique: true, quantity: 1, promotes_from: ['Mitron'], guild_affiliation: 'Guilde des Artisans' }, 
                    { role: 'Mitron', tier: 4, master: 'Maître Boulanger', quantity: 2, guild_source: 'Guilde des Artisans' }
                ],
                'Menuisier / Charpentier': [
                    { role: 'Maître Artisan', tier: 3, unique: true, quantity: 1, promotes_from: ['Compagnon'], guild_affiliation: 'Guilde des Artisans' }, 
                    { role: 'Compagnon', tier: 4, master: 'Maître Artisan', dynamic_quantity_per_pop: 80, guild_source: 'Guilde des Artisans' }
                ],
                'Tanneur / Maroquinier': [
                    { role: 'Maître Tanneur', tier: 3, unique: true, quantity: 1, promotes_from: ['Ouvrier du cuir'], guild_affiliation: 'Guilde des Artisans' }, 
                    { role: 'Ouvrier du cuir', tier: 4, master: 'Maître Tanneur', dynamic_quantity_per_pop: 100, guild_source: 'Guilde des Artisans' }
                ],
                'Herboristerie': [
                    { role: 'Herboriste', tier: 3, unique: true, quantity: 1 }, 
                    { role: 'Cueilleur', tier: 4, quantity: 2 }
                ],
                'Brasserie / Distillerie': [
                    { role: 'Maître Brasseur', tier: 3, unique: true, quantity: 1, promotes_from: ['Goûteur'], guild_affiliation: 'Guilde des Artisans' }, 
                    { role: 'Goûteur', tier: 4, master: 'Maître Brasseur', quantity: 2, guild_source: 'Guilde des Artisans' }
                ],
                'Tisserand / Tailleur': [
                    { role: 'Maître Tisserand', tier: 3, unique: true, quantity: 1, promotes_from: ['Couturier/ère'], guild_affiliation: 'Guilde des Artisans' }, 
                    { role: 'Couturier/ère', tier: 4, master: 'Maître Tisserand', dynamic_quantity_per_pop: 80, guild_source: 'Guilde des Artisans' }
                ],
                'Temple / Église': [
                    { role: 'Grand(e) Prêtre/Prêtresse', tier: 2, unique: true, quantity: 1, promotes_from: ['Acolyte', 'Soigneur du Temple'] },
                    { role: 'Gardien du Temple', tier: 3, dynamic_quantity_per_pop: 200 },
                    { role: 'Soigneur du Temple', tier: 3, dynamic_quantity_per_pop: 180 },
                    { role: 'Moine / Scribe du Temple', tier: 3, dynamic_quantity_per_pop: 250 },
                    { role: 'Acolyte', tier: 4, master: 'Grand(e) Prêtre/Prêtresse', dynamic_quantity_per_pop: 120 }
                ],
                'Caserne / Garde': [
                    { role: 'Sergent', tier: 3, dynamic_quantity_per_pop: 200, promotes_from: ['Soldat de la garde'], guild_affiliation: 'Guilde des Combattants' },
                    { role: 'Armurier de la garde', tier: 3, quantity: 1, guild_affiliation: 'Guilde des Artisans' },
                    { role: 'Soldat de la garde', tier: 4, master: 'Sergent', dynamic_quantity_per_pop: 50, guild_source: 'Guilde des Combattants' }
                ],
                'Château / Manoir': [
                    { role: 'Intendant(e)', tier: 2, unique: true, quantity: 1 },
                    { role: 'Chef Cuisinier', tier: 3, quantity: 1 },
                    { role: 'Garde du corps personnel', tier: 3, quantity: 4, guild_affiliation: 'Guilde des Combattants' },
                    { role: 'Maître des chasses', tier: 3, quantity: 1 },
                    { role: 'Domestique', tier: 5, dynamic_quantity_per_pop: 40 }
                ],
                'Bibliothèque / Scriptorium': [
                    { role: 'Maître Bibliothécaire', tier: 2, unique: true, quantity: 1, promotes_from: ['Archiviste', 'Copiste / Scribe'], guild_affiliation: 'Guilde des Érudits' }, 
                    { role: 'Copiste / Scribe', tier: 3, master: 'Maître Bibliothécaire', quantity: 3, guild_source: 'Guilde des Érudits' }, 
                    { role: 'Archiviste', tier: 3, quantity: 1, guild_source: 'Guilde des Érudits' }
                ],
                "Échoppe d'alchimiste": [
                    { role: 'Maître Alchimiste', tier: 2, unique: true, quantity: 1, promotes_from: ["Assistant(e) Alchimiste"], guild_affiliation: 'Guilde des Érudits' }, 
                    { role: 'Assistant(e) Alchimiste', tier: 4, master: 'Maître Alchimiste', quantity: 1, guild_source: 'Guilde des Érudits' }
                ],
                'Atelier de mage': [
                    { role: 'Mage résident', tier: 2, unique: true, quantity: 1, promotes_from: ["Apprenti(e) mage"], guild_affiliation: 'Guilde des Érudits' }, 
                    { role: 'Apprenti(e) mage', tier: 4, master: 'Mage résident', quantity: 1, guild_source: 'Guilde des Érudits' }
                ],
                'Observatoire': [
                    { role: 'Astronome', tier: 2, unique: true, quantity: 1, guild_affiliation: 'Guilde des Érudits' }
                ],
                'Arène / Colisée': [
                    { role: 'Maître des jeux', tier: 2, unique: true, quantity: 1, promotes_from: ['Gladiateur'], guild_affiliation: 'Guilde des Combattants' }, 
                    { role: 'Gladiateur', tier: 3, quantity: 5, guild_source: 'Guilde des Combattants' },
                    { role: 'Soigneur de l\'arène', tier: 3, quantity: 1 }
                ]
            },
            autonomous_jobs: [
                { role: 'Chasseur / Piégeur', tier: 4 }, { role: 'Pêcheur', tier: 4 }, { role: 'Bûcheron / Charbonnier', tier: 4 }, 
                { role: 'Mineur / Carrier', tier: 4 }, { role: 'Fermier / Éleveur', tier: 4 }, { role: 'Messager', tier: 4 }, 
                { role: 'Barde / Ménestrel', tier: 3 }, { role: 'Mercenaire', tier: 3 }, { role: 'Éclaireur', tier: 3 },
                { role: 'Mendiant', tier: 5, isBeggar: true }
            ]
        };

        const DYNAMIC_BUILDING_TIERS = {
            TIER1: { threshold: 75, types: ["Boulangerie", "Forge", "Menuisier / Charpentier"] },
            TIER2: { threshold: 150, types: ["Taverne / Auberge", "Herboristerie", "Tisserand / Tailleur", "Tanneur / Maroquinier"] },
            TIER3: { threshold: 300, types: ["Temple / Église", "Brasserie / Distillerie"] }
        };

        // --- FONCTIONS UTILITAIRES ---
        function offsetToCube(q, r) { const x = q; const z = r - (q + (q & 1)) / 2; const y = -x - z; return { x, y, z }; }
        function cubeDistance(a, b) { return (Math.abs(a.x - b.x) + Math.abs(a.y - b.y) + Math.abs(a.z - b.z)) / 2; }
        
        // --- FONCTIONS PRINCIPALES DE L'APPLICATION ---
        
        // MODIFICATION 2: Crée une fonction pour charger les données de manière asynchrone.
        // "async" signifie que cette fonction peut faire une pause en attendant une réponse (comme un fichier).
        async function loadPresetRaces() {
            try {
                // "fetch" est la commande standard pour demander un fichier au serveur.
                const response = await fetch('races.json'); // On attend la réponse du serveur.
                
                // Si le serveur répond qu'il n'a pas trouvé le fichier ou qu'il y a eu un problème.
                if (!response.ok) {
                    throw new Error(`Erreur HTTP! Statut: ${response.status}`);
                }
                
                // On transforme la réponse (qui est du texte) en un véritable objet JavaScript.
                const data = await response.json();
                
                // On stocke les données chargées dans notre variable.
                PRESET_RACES = data;
                console.log("Les races pré-définies ont été chargées avec succès !");

            } catch (error) {
                console.error("Impossible de charger le fichier races.json:", error);
                alert("ERREUR : Impossible de charger les données des races. Assurez-vous que le fichier 'races.json' existe bien et que vous avez lancé le serveur web local (voir instructions).");
            }
        }

        // MODIFICATION 3: La fonction principale d'initialisation devient "async"
        // pour qu'elle puisse attendre le chargement des races avant de continuer.
        async function initializePage() {
            // On lance le chargement et on ATTEND ("await") qu'il soit terminé.
            await loadPresetRaces();

            // Le reste du code ne s'exécute que lorsque les races sont chargées.
            loadAllRegions();
            totalFamiliesInput.value = calculateTotalFamilies();
            loadRacesFromDB();
            populatePresetRacesDropdown(); // Maintenant, cette fonction peut utiliser PRESET_RACES qui est rempli.
            updateUiState();
            
            addRaceBtn.addEventListener('click', () => createAndPopulateRaceCard());
            saveRacesBtn.addEventListener('click', saveRacesToDB);
            loadPresetRaceBtn.addEventListener('click', handleLoadPresetRace);
            startSimBtn.addEventListener('click', generateG0);
            viewResultsBtn.addEventListener('click', displayPopulation);
            
            populationModal.querySelector('.modal-close').addEventListener('click', () => {
                populationModal.style.display = 'none';
            });

            const historyModalClose = document.getElementById('history-modal-close');
            historyModalClose.addEventListener('click', () => {
                historyModal.style.display = 'none';
            });
            historyModal.addEventListener('click', (event) => {
                if (event.target === historyModal) {
                    historyModal.style.display = 'none';
                }
            });

            document.body.addEventListener('click', function(event) {
                if (event.target && event.target.classList.contains('open-history-modal-btn')) {
                    const button = event.target;
                    const familyId = button.dataset.familyId;
                    const familyName = button.dataset.familyName;
                    openHistoryModal(familyId, familyName);
                }
            });
        }
        
        function populatePresetRacesDropdown() {
            // Cette fonction n'a pas besoin de changer ! Elle fonctionne parfaitement
            // avec l'objet PRESET_RACES une fois qu'il est rempli.
            for (const raceName in PRESET_RACES) {
                const option = document.createElement('option');
                option.value = raceName;
                option.textContent = raceName;
                presetRaceSelect.appendChild(option);
            }
        }

        // ... Le reste de votre code JavaScript (de handleLoadPresetRace à la fin) reste INCHANGÉ ...
        // Je le remets ici pour que vous ayez le bloc complet à copier/coller.

        function handleLoadPresetRace() {
            const selectedRaceName = presetRaceSelect.value;
            if (selectedRaceName && PRESET_RACES[selectedRaceName]) {
                const existingNames = Array.from(document.querySelectorAll('.race-name')).map(input => input.value.trim().toLowerCase());
                if (existingNames.includes(selectedRaceName.toLowerCase())) {
                    alert(`La race "${selectedRaceName}" est déjà présente dans la liste.`);
                    return;
                }
                createAndPopulateRaceCard(PRESET_RACES[selectedRaceName]);
                updateUiState();
            }
            presetRaceSelect.value = ""; // Reset dropdown
        }

        function openHistoryModal(familyId, familyName) {
            const title = document.getElementById('history-modal-title');
            const body = document.getElementById('history-modal-body');

            title.textContent = `Historique de la famille ${familyName}`;

            const fullHistory = simulation.eventLog
                .filter(e => e.familyId === familyId)
                .slice()
                .reverse();

            const listHtml = fullHistory.map(event => {
                const message = event.message.replace(/<\/?h3>/g, '').trim();
                if (message) {
                    return `<li><strong>Année ${event.year}:</strong> ${message}</li>`;
                }
                return '';
            }).join('');

            body.innerHTML = `<ul class="family-history">${listHtml}</ul>`;
            historyModal.style.display = 'flex';
        }

        function logEvent(message, cityId = null, familyId = null, meta = {}) {
            simulation.eventLog.push({
                year: simulation.year,
                cityId: cityId,
                familyId: familyId,
                message: message,
                meta: meta
            });
        }
        
        function saveRacesToDB() {
            const racesDB = {};
            document.querySelectorAll('.race-card').forEach(card => {
                const name = card.querySelector('.race-name').value.trim();
                if (!name) return;
                racesDB[name] = {
                    name: name,
                    lifespan: parseInt(card.querySelector('.race-lifespan').value),
                    adultAge: parseInt(card.querySelector('.race-adultage').value),
                    firstNamesM: card.querySelector('.race-firstnames-m').value,
                    firstNamesF: card.querySelector('.race-firstnames-f').value,
                    lastNames: card.querySelector('.race-lastnames').value
                };
            });
            localStorage.setItem('allRacesDB', JSON.stringify(racesDB));
            alert(`${Object.keys(racesDB).length} race(s) sauvegardée(s) !`);
        }

        function loadRacesFromDB() {
            const savedRaces = localStorage.getItem('allRacesDB');
            if (savedRaces) {
                const racesDB = JSON.parse(savedRaces);
                raceListDiv.innerHTML = '';
                if (Object.keys(racesDB).length > 0) {
                    Object.values(racesDB).forEach(raceData => {
                        createAndPopulateRaceCard(raceData);
                    });
                } else {
                    createAndPopulateRaceCard();
                }
            } else {
                createAndPopulateRaceCard();
            }
        }

        function createAndPopulateRaceCard(raceData = {}) {
            if (!raceCardTemplate) return;
            const cardClone = raceCardTemplate.content.cloneNode(true);
            const raceCard = cardClone.querySelector('.race-card');
            if (!raceCard) return;
            raceCard.querySelector('.race-name').value = raceData.name || '';
            raceCard.querySelector('h4').textContent = raceData.name || 'Nouvelle Race';
            raceCard.querySelector('.race-lifespan').value = raceData.lifespan || 80;
            raceCard.querySelector('.race-adultage').value = raceData.adultAge || 18;
            raceCard.querySelector('.race-firstnames-m').value = raceData.firstNamesM || '';
            raceCard.querySelector('.race-firstnames-f').value = raceData.firstNamesF || '';
            raceCard.querySelector('.race-lastnames').value = raceData.lastNames || '';
            raceCard.querySelector('.delete-race-btn').addEventListener('click', () => {
                raceCard.remove();
                updateUiState();
            });
            raceCard.querySelectorAll('input, textarea').forEach(el => {
                el.addEventListener('input', updateUiState);
            });
            raceListDiv.appendChild(cardClone);
        }

        function loadAllRegions() {
            const savedData = localStorage.getItem('allRegionsData');
            if (savedData) {
                allRegions = JSON.parse(savedData);
            } else {
                allRegions = {
                    currentRegionName: 'Ma Première Région',
                    regions: { 'Ma Première Région': { hexDistance: 10, cities: [] } }
                };
            }
        }

        function getCurrentRegion() {
            if (allRegions && allRegions.currentRegionName && allRegions.regions) {
                return allRegions.regions[allRegions.currentRegionName];
            }
            return null;
        }

        function calculateTotalFamilies() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion || !currentRegion.cities) return 0;
            return currentRegion.cities.reduce((total, city) => total + (city.config?.g0_families || 0), 0);
        }

        function updateUiState() {
            const percentages = Array.from(document.querySelectorAll('.race-percentage'));
            const total = percentages.reduce((sum, input) => sum + (parseFloat(input.value) || 0), 0);
            totalPercentageP.textContent = `Total des pourcentages : ${total}%`;
            checkPercentEl.textContent = `Le total des pourcentages des races doit être 100%. (Actuel: ${total}%)`;
            const percentValid = (total === 100);
            checkPercentEl.className = percentValid ? 'valid' : 'invalid';
            const g0families = parseInt(totalFamiliesInput.value);
            checkFamiliesEl.textContent = `Il doit y avoir au moins une famille fondatrice. (Actuel: ${g0families})`;
            const familiesValid = g0families > 0;
            checkFamiliesEl.className = familiesValid ? 'valid' : 'invalid';
            const racesValid = allRacesHaveData();
            checkRacesEl.textContent = `Toutes les fiches de race doivent être complètes (Nom, Prénoms M/F, Noms).`;
            checkRacesEl.className = racesValid ? 'valid' : 'invalid';
            startSimBtn.disabled = !(percentValid && familiesValid && racesValid);
        }
        
        function allRacesHaveData(){
            if (document.querySelectorAll('.race-card').length === 0) return false;
            return Array.from(document.querySelectorAll('.race-card')).every(card => {
                return card.querySelector('.race-name').value.trim() &&
                       card.querySelector('.race-firstnames-m').value.trim() &&
                       card.querySelector('.race-firstnames-f').value.trim() &&
                       card.querySelector('.race-lastnames').value.trim();
            });
        }

        function collectConfigData() {
            const raceCards = document.querySelectorAll('.race-card');
            const racesConfig = {};
            raceCards.forEach(card => {
                const name = card.querySelector('.race-name').value.trim();
                if (!name) return;
                racesConfig[name] = {
                    lifespan: parseInt(card.querySelector('.race-lifespan').value),
                    adultAge: parseInt(card.querySelector('.race-adultage').value),
                    firstNamesM: card.querySelector('.race-firstnames-m').value.split(',').map(n => n.trim()).filter(Boolean),
                    firstNamesF: card.querySelector('.race-firstnames-f').value.split(',').map(n => n.trim()).filter(Boolean),
                    lastNames: card.querySelector('.race-lastnames').value.split(',').map(n => n.trim()).filter(Boolean),
                    percentage: parseFloat(card.querySelector('.race-percentage').value)
                };
            });
            return racesConfig;
        }

        function weightedRandom(items) {
            const totalWeight = Object.values(items).reduce((sum, race) => sum + race.percentage, 0);
            let random = Math.random() * totalWeight;
            for (const name in items) {
                random -= items[name].percentage;
                if (random <= 0) { return name; }
            }
        }
        
        let nextPersonId = 0;
        let nextBuildingId = 0;
        function createPerson(raceName, familyName, familyId, gender, age = null, cityId, cityName, parents = []) {
            const raceInfo = simulation.races[raceName];
            if (!raceInfo) return null;
            const nameList = (gender === 'M') ? raceInfo.firstNamesM : raceInfo.firstNamesF;
            if (nameList.length === 0) return null;
            const personAge = age !== null ? age : Math.floor(Math.random() * 21) + 20;
            return {
                id: nextPersonId++, firstName: nameList[Math.floor(Math.random() * nameList.length)],
                lastName: familyName, maidenName: null,
                age: personAge, gender: gender,
                race: raceName, isAlive: true, familyId: familyId,
                cityId: cityId, cityName: cityName, 
                originCityId: cityId, originCityName: cityName,
                wasMarried: false,
                job: null,
                parents: parents, spouseId: null, children: []
            };
        }
        
        async function runFullSimulation() {
            startSimBtn.disabled = true;
            startSimBtn.textContent = 'Simulation en cours...';

            for (let i = 0; i < 100; i++) {
                advanceTime();
                displayPopulation();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            logEvent(`<strong>FIN:</strong> La simulation s'est terminée après 100 ans.`, null, null);
            displayPopulation();
            startSimBtn.textContent = 'Simulation terminée';
        }

        function generateG0() {
            simulation.races = collectConfigData();
            simulation.population = [];
            simulation.families = {};
            simulation.eventLog = [];
            nextPersonId = 0;
            nextBuildingId = 0;
            simulation.year = 0;
            currentYearInput.value = 'Année 0';

            const currentRegion = getCurrentRegion();
            if(!currentRegion) return;
            
            currentRegion.cities.forEach(city => {
                if(!city.config) city.config = {};
                city.config.dynamic_buildings = [];
                city.config.guilds = [];
            });

            const familySlots = [];
            currentRegion.cities.forEach(city => {
                const numFamilies = city.config?.g0_families || 0;
                for (let i = 0; i < numFamilies; i++) {
                    familySlots.push({ cityId: city.id, cityName: city.name });
                }
            });
            familySlots.forEach((slot, index) => {
                const familyId = `F${index}`;
                const raceName = weightedRandom(simulation.races);
                if (!raceName) return;
                const raceInfo = simulation.races[raceName];
                const familyName = raceInfo.lastNames[Math.floor(Math.random() * raceInfo.lastNames.length)] || `Famille ${index}`;
                
                const age1 = Math.floor(Math.random() * 7) + 18;
                const minAge2 = Math.max(18, age1 - 5);
                const maxAge2 = Math.min(24, age1 + 5);
                const age2 = Math.floor(Math.random() * (maxAge2 - minAge2 + 1)) + minAge2;

                const person1 = createPerson(raceName, familyName, familyId, 'M', age1, slot.cityId, slot.cityName);
                const person2 = createPerson(raceName, familyName, familyId, 'F', age2, slot.cityId, slot.cityName);
                
                if (person1 && person2) {
                    person1.spouseId = person2.id;
                    person2.spouseId = person1.id;
                    simulation.population.push(person1, person2);
                    simulation.families[familyId] = { 
                        originalName: familyName, 
                        members: [person1.id, person2.id],
                        location: slot.cityName
                    };
                }
            });
            assignJobs();
            logEvent(`<strong>Année 0 :</strong> Fondation de la région avec ${simulation.population.length} personnes. Les premiers métiers ont été assignés.`, null, null);
            
            viewResultsBtn.disabled = false;
            displayPopulation();
            runFullSimulation();
        }
        
        function advanceTime() {
            simulation.year += 1;
            logEvent(`<h3>--- Année ${simulation.year} ---</h3>`, null, null);
            const currentRegion = getCurrentRegion();
            if (currentRegion) {
                currentRegion.cities.forEach(city => {
                    updateCityInfrastructure(city);
                    updateGuilds(city);
                });
            }
            simulation.population.forEach(p => { if(p.isAlive) p.age += 1; });
            simulation.population.forEach(p => {
                if (p.isAlive && p.yearsSinceMigration !== undefined) {
                    p.yearsSinceMigration++;
                }
            });
            handleDeaths();
            checkForFamilyExtinction();
            handleMarriages();
            handleEconomicMigration();
            processMigrationImpact();
            handleBirths();
            assignJobs();
            currentYearInput.value = `Année ${simulation.year}`;
        }

        function updateGuilds(city) {
            if (!city.config) return;

            const cityBuildings = new Set(Object.keys(city.config.buildings || {}).filter(b => city.config.buildings[b]));
            const cityPopulation = simulation.population.filter(p => p.isAlive && p.cityId === city.id).length;

            for (const [guildName, data] of Object.entries(guildData)) {
                const existingGuild = city.config.guilds.find(g => g.name === guildName);
                
                const buildingsOwned = [...cityBuildings].filter(b => data.required_buildings.includes(b)).length;

                if (!existingGuild && cityPopulation >= data.min_pop && buildingsOwned >= data.min_buildings) {
                    city.config.guilds.push({ name: guildName });
                    logEvent(`🏛️ La <strong>${guildName}</strong> a été fondée à ${city.name} !`, city.id, null);
                }
            }
        }

        function updateCityInfrastructure(city) {
            if (!city.config) return;
            const populationInCity = simulation.population.filter(p => p.isAlive && p.cityId === city.id).length;

            for (const tierInfo of Object.values(DYNAMIC_BUILDING_TIERS)) {
                if (populationInCity > tierInfo.threshold) {
                    const targetCount = Math.floor(populationInCity / tierInfo.threshold);
                    const currentCount = city.config.dynamic_buildings.filter(b => tierInfo.types.includes(b.name)).length;

                    if (targetCount > currentCount && Math.random() < 0.20) {
                        const newBuildingType = tierInfo.types[Math.floor(Math.random() * tierInfo.types.length)];
                        city.config.dynamic_buildings.push({ id: `bld_${nextBuildingId++}`, name: newBuildingType });
                        logEvent(`📈 Une nouvelle ${newBuildingType} a ouvert à ${city.name}.`, city.id, null);
                        break;
                    }
                }
            }

             for (const tierInfo of Object.values(DYNAMIC_BUILDING_TIERS)) {
                const targetCount = Math.floor(populationInCity / tierInfo.threshold);
                const buildingsOfType = city.config.dynamic_buildings.filter(b => tierInfo.types.includes(b.name));
                const currentCount = buildingsOfType.length;
                
                if (currentCount > targetCount && Math.random() < 0.15) {
                    const buildingToRemove = buildingsOfType[Math.floor(Math.random() * buildingsOfType.length)];
                    
                    const employees = simulation.population.filter(p => p.job?.buildingInstanceId === buildingToRemove.id);
                    if (employees.length > 0) {
                        const employeeNames = employees.map(e => `${e.firstName} ${e.lastName} (${e.job.role})`).join(', ');
                        logEvent(`📉 La ${buildingToRemove.name} de ${city.name} a fermé. Employés licenciés : ${employeeNames}.`, city.id, null);
                        employees.forEach(e => { e.job = null; });
                    } else {
                        logEvent(`📉 Une ${buildingToRemove.name} superflue a fermé à ${city.name}.`, city.id, null);
                    }
                    
                    city.config.dynamic_buildings = city.config.dynamic_buildings.filter(b => b.id !== buildingToRemove.id);
                    break;
                }
            }
        }
        
        function getCityJobStatus(city) {
            const cityPopulation = simulation.population.filter(p => p.isAlive && p.cityId === city.id);
            const popCount = cityPopulation.length;
            const jobStatus = { buildings: [], guilds: [], autonomous: [] };

            const allBuildings = [
                ...Object.entries(city.config?.buildings || {}).filter(([, exists]) => exists).map(([name]) => ({ id: `static_${name.replace(/[^a-z]/gi, '')}`, name })), 
                ...(city.config?.dynamic_buildings || [])
            ];

            const filledJobs = cityPopulation.map(p => p.job).filter(Boolean);

            allBuildings.forEach(building => {
                const buildingInfo = { name: building.name, jobs: [] };
                const jobDefs = jobData.building_jobs[building.name] || [];

                jobDefs.forEach(def => {
                    let required = def.quantity || 0;
                    if (def.dynamic_quantity_per_pop) {
                        required += Math.floor(popCount / def.dynamic_quantity_per_pop);
                    }

                    if (required > 0) {
                        let filled;
                         if (building.id.startsWith('static')) {
                            filled = filledJobs.filter(j => j.role === def.role && !j.buildingInstanceId).length;
                         } else {
                            filled = filledJobs.filter(j => j.role === def.role && j.buildingInstanceId === building.id).length;
                         }
                        buildingInfo.jobs.push({ role: def.role, required, filled });
                    }
                });
                if(buildingInfo.jobs.length > 0) {
                   jobStatus.buildings.push(buildingInfo);
                }
            });

            (city.config.guilds || []).forEach(guild => {
                const guildDef = guildData[guild.name];
                if(guildDef) {
                    const masterFilled = filledJobs.filter(j => j.role === guildDef.master_role).length;
                    const membersFilled = filledJobs.filter(j => j.role === guildDef.member_role).length;
                    const memberRequired = Math.floor(popCount / 50);
                    
                    jobStatus.guilds.push({
                        name: guild.name,
                        jobs: [
                            {role: guildDef.master_role, required: 1, filled: masterFilled},
                            {role: guildDef.member_role, required: memberRequired, filled: membersFilled}
                        ]
                    });
                }
            });
            
            jobData.autonomous_jobs.forEach(def => {
                const filled = filledJobs.filter(j => j.role === def.role).length;
                if (filled > 0 || !def.isBeggar) {
                    jobStatus.autonomous.push({ role: def.role, required: 'N/A', filled });
                }
            });

            return jobStatus;
        }

        function assignJobs() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;

            currentRegion.cities.forEach(city => {
                const populationInCity = simulation.population.filter(p => p.isAlive && p.cityId === city.id);
                const cityPopulationCount = populationInCity.length;
                if(cityPopulationCount === 0) return;

                let vacantJobs = [];
                let requiredJobsList = [];

                (jobData.base_jobs[city.type] || []).forEach(j => requiredJobsList.push({...j}));
                const allBuildings = [
                    ...Object.entries(city.config?.buildings || {}).filter(([, exists]) => exists).map(([name]) => ({ id: `static_${name.replace(/[^a-z]/gi, '')}`, name })), 
                    ...(city.config?.dynamic_buildings || [])
                ];
                allBuildings.forEach(building => {
                    (jobData.building_jobs[building.name] || []).forEach(jobDef => {
                        let quantity = jobDef.quantity || 0;
                        if(jobDef.dynamic_quantity_per_pop) quantity += Math.floor(cityPopulationCount / jobDef.dynamic_quantity_per_pop);
                        for(let i=0; i<quantity; i++) requiredJobsList.push({...jobDef, buildingInstanceId: building.id.startsWith('bld_') ? building.id : undefined });
                    });
                });
                (city.config.guilds || []).forEach(guild => {
                    const guildDef = guildData[guild.name];
                    if (guildDef) {
                        requiredJobsList.push({ role: guildDef.master_role, tier: 2 });
                        const memberCount = Math.floor(cityPopulationCount / 50);
                        for (let i = 0; i < memberCount; i++) {
                            requiredJobsList.push({ role: guildDef.member_role, tier: 3, isGuildMember: true, guildName: guild.name });
                        }
                    }
                });

                const filledJobCounts = {};
                populationInCity.forEach(p => {
                    if (p.job) {
                        const key = p.job.buildingInstanceId ? `${p.job.role}_${p.job.buildingInstanceId}` : p.job.role;
                        filledJobCounts[key] = (filledJobCounts[key] || 0) + 1;
                    }
                });
                 const requiredJobCounts = {};
                 requiredJobsList.forEach(jobInfo => {
                    const key = jobInfo.buildingInstanceId ? `${jobInfo.role}_${jobInfo.buildingInstanceId}` : jobInfo.role;
                    requiredJobCounts[key] = (requiredJobCounts[key] || 0) + 1;
                });
                for(const key in requiredJobCounts) {
                    const needed = requiredJobCounts[key] - (filledJobCounts[key] || 0);
                    if(needed > 0) {
                        const jobTemplate = requiredJobsList.find(j => (j.buildingInstanceId ? `${j.role}_${j.buildingInstanceId}` : j.role) === key);
                        for(let i=0; i<needed; i++) vacantJobs.push({...jobTemplate});
                    }
                }
                vacantJobs.sort((a, b) => (a.tier || 99) - (b.tier || 99));
                
                let availableCandidates = populationInCity.filter(p => !p.job);
                vacantJobs.forEach(vacantJob => {
                    if (availableCandidates.length === 0 && !vacantJob.promotes_from && !vacantJob.guild_affiliation) return;
                    
                    let candidate = null, isPromotion = false, promotionSource = '';

                    if (vacantJob.promotes_from) {
                        const promotionCandidates = populationInCity
                            .filter(p => p.job && vacantJob.promotes_from.includes(p.job.role))
                            .sort((a,b) => b.age - a.age); 
                        if(promotionCandidates.length > 0) {
                            candidate = promotionCandidates[0];
                            isPromotion = true;
                            promotionSource = `son poste de ${candidate.job.role}`;
                        }
                    }

                    if (!candidate && vacantJob.guild_affiliation) {
                        const guildDef = guildData[vacantJob.guild_affiliation];
                        if (guildDef) {
                            const guildMembers = populationInCity.filter(p => p.job?.role === guildDef.member_role);
                            if (guildMembers.length > 0) {
                                guildMembers.sort((a,b) => b.age - a.age);
                                candidate = guildMembers[0];
                                isPromotion = true;
                                promotionSource = `la ${vacantJob.guild_affiliation}`;
                            }
                        }
                    }

                    if (!candidate) {
                        if(availableCandidates.length === 0) return;
                        
                        let hirePool = availableCandidates.filter(p => p.age >= (simulation.races[p.race]?.adultAge || 18));
                        
                        if (vacantJob.guild_source) {
                            const guildDef = guildData[vacantJob.guild_source];
                            if(guildDef) {
                                const guildPool = hirePool.filter(p => p.job?.role === guildDef.member_role);
                                if(guildPool.length > 0) hirePool = guildPool;
                            }
                        }

                        if (vacantJob.tier <= 3) {
                             const qualifiedPool = hirePool.filter(p => p.age > 25);
                             if (qualifiedPool.length > 0) hirePool = qualifiedPool;
                        }
                        if (hirePool.length > 0) {
                            hirePool.sort((a,b) => b.age - a.age); 
                            candidate = hirePool[0];
                        }
                    }
                    
                    if(candidate) {
                        if(isPromotion) {
                            logEvent(`⬆️ ${candidate.firstName} ${candidate.lastName} a été promu(e) au poste de ${vacantJob.role} depuis ${promotionSource} à ${city.name}.`, city.id, candidate.familyId);
                        } else {
                            logEvent(`💼 ${candidate.firstName} ${candidate.lastName} a été embauché(e) comme ${vacantJob.role} à ${city.name}.`, city.id, candidate.familyId);
                        }
                        candidate.job = { ...vacantJob }; 
                        if(!isPromotion) {
                           availableCandidates = availableCandidates.filter(p => p.id !== candidate.id);
                        }
                    }
                });
                
                let unemployedAdults = availableCandidates.filter(p => p.age >= (simulation.races[p.race]?.adultAge || 18));

                const cityStatus = city.config.city_status;
                const beggarJob = jobData.autonomous_jobs.find(j => j.isBeggar);

                if (beggarJob && (cityStatus === 'difficulte' || cityStatus === 'declin')) {
                    const BEGGAR_CHANCES = {
                        'difficulte': 0.03,
                        'declin': 0.07
                    };
                    const chance = BEGGAR_CHANCES[cityStatus] || 0;

                    if (chance > 0) {
                        unemployedAdults.forEach(person => {
                            if(!person.job && Math.random() < chance) {
                                person.job = {...beggarJob};
                            }
                        });
                        unemployedAdults = unemployedAdults.filter(p => !p.job);
                    }
                }
                
                const autonomousJobs = jobData.autonomous_jobs.filter(j => !j.isBeggar);
                unemployedAdults.forEach(person => {
                    if (Math.random() < 0.25) {
                        const jobPool = Math.random() < 0.8 
                            ? autonomousJobs.filter(j => j.tier === 4) 
                            : autonomousJobs.filter(j => j.tier === 3);
                            
                        if (jobPool.length > 0) {
                            person.job = jobPool[Math.floor(Math.random() * jobPool.length)];
                        }
                    }
                });
            });
        }

        function degradeCityStatus(city, severity = 1) {
            const progressionArray = ['prospere', 'stable', 'difficulte', 'declin'];
            const progressionMap = {
                'prospere': 0,
                'stable': 1,
                'difficulte': 2,
                'declin': 3
            };

            const oldStatus = city.config.city_status || 'stable';
            const currentIndex = progressionMap[oldStatus];
            if(currentIndex === undefined) return;

            const newIndex = Math.min(progressionArray.length - 1, currentIndex + severity);
            const newStatus = progressionArray[newIndex];
            
            if (oldStatus !== newStatus) {
                city.config.city_status = newStatus;
                logEvent(`📉 À cause d'un afflux soudain de population, le statut de <strong>${city.name}</strong> s'est ${severity > 1 ? 'sévèrement ' : ''}dégradé de '${oldStatus}' à '${newStatus}'.`, city.id, null);
            }
        }

        function processMigrationImpact() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;

            const MIGRATION_IMPACT_THRESHOLD = 1;
            const beggarJob = jobData.autonomous_jobs.find(j => j.isBeggar);

            currentRegion.cities.forEach(city => {
                const cityPopulation = simulation.population.filter(p => p.isAlive && p.cityId === city.id).length;
                if (cityPopulation === 0) return;

                const opportunityMigrantsEvents = simulation.eventLog.filter(e =>
                    e.year === simulation.year &&
                    e.cityId === city.id &&
                    e.message.startsWith('✨') &&
                    e.meta && e.meta.personId
                );

                const migrantCount = opportunityMigrantsEvents.length;
                
                if (migrantCount === 0) return;

                const migrationPercentage = (migrantCount / (cityPopulation - migrantCount)) * 100;

                if (migrationPercentage > MIGRATION_IMPACT_THRESHOLD) {
                    let severity = 1;
                    if (migrationPercentage > 3) {
                        severity = 2;
                    }
                    degradeCityStatus(city, severity);

                    if (beggarJob) {
                        opportunityMigrantsEvents.forEach(event => {
                            const migrant = simulation.population.find(p => p.id === event.meta.personId);
                            if (migrant && migrant.isAlive && !migrant.job) {
                                migrant.job = { ...beggarJob };
                                logEvent(`🙏 Arrivé sans ressources, ${migrant.firstName} ${migrant.lastName} est devenu mendiant à ${city.name}.`, city.id, migrant.familyId);
                            }
                        });
                    }
                }
            });
        }

        function handleDeaths() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;

            simulation.population.forEach(person => {
                if (!person.isAlive) return;
                const raceInfo = simulation.races[person.race];
                if (!raceInfo) return;

                let died = false;
                let deathChance = 0;
                if (person.age > raceInfo.lifespan) {
                    deathChance = (person.age - raceInfo.lifespan) / 15;
                } else if (person.age > raceInfo.lifespan * 0.9) {
                    deathChance = 0.005;
                }
                if (Math.random() < deathChance) {
                    logEvent(`🕊️ ${person.firstName} ${person.lastName} (${person.job?.role || 'Sans emploi'}) est décédé(e) de vieillesse à ${person.age} ans à ${person.cityName}.`, person.cityId, person.familyId);
                    died = true;
                }

                if (!died && person.age > 16 && person.age < (raceInfo.lifespan * 0.85)) {
                    const city = currentRegion.cities.find(c => c.id === person.cityId);
                    const cityStatus = city?.config?.city_status || 'stable';
                    let diedPrematurely = false;
                    let causeOfDeathMessage = '';

                    const crimeDeathCauses = ["tué(e) lors d'un vol", "victime d'une agression de rue", "assassiné(e) par un rival", "pris(e) dans un règlement de comptes"];
                    const famineDeathCauses = ["mort(e) de faim", "mort(e) de malnutrition due à la famine", "décédé(e) des suites de la disette"];
                    const genericPrematureDeathCauses = ["d'une maladie soudaine", "d'un accident de travail", "d'une rixe qui a mal tourné", "en protégeant un proche", "d'une chute malencontreuse", "des mauvaises conditions de vie", "d'une épidémie locale"];

                    const statusDeathRates = {
                        'prospere':   { generic: 0.0010, crime: 0.0000, famine: 0.0000 },
                        'stable':     { generic: 0.0015, crime: 0.0001, famine: 0.0000 },
                        'difficulte': { generic: 0.0020, crime: 0.0015, famine: 0.0005 },
                        'declin':     { generic: 0.0025, crime: 0.0035, famine: 0.0025 }
                    };
                    
                    const rates = statusDeathRates[cityStatus] || statusDeathRates['stable'];
                    let finalRates = { ...rates };

                    let riskMultiplier = 1.0;
                    if (person.yearsSinceMigration !== undefined && person.yearsSinceMigration < 5) {
                        riskMultiplier = 2.5; 
                    } else if (!person.job || person.job.isBeggar) {
                        riskMultiplier = 2.0; 
                    }

                    finalRates.crime *= riskMultiplier;
                    finalRates.famine *= riskMultiplier;
                    finalRates.generic *= (riskMultiplier > 1.0 ? 1.2 : 1.0);

                    if (Math.random() < finalRates.famine) {
                        diedPrematurely = true;
                        const cause = famineDeathCauses[Math.floor(Math.random() * famineDeathCauses.length)];
                        causeOfDeathMessage = `💀 ${person.firstName} ${person.lastName} est ${cause} à ${person.age} ans, victime de la famine qui frappe ${person.cityName}.`;
                    } else if (Math.random() < finalRates.crime) {
                        diedPrematurely = true;
                        const cause = crimeDeathCauses[Math.floor(Math.random() * crimeDeathCauses.length)];
                        causeOfDeathMessage = `💀 ${person.firstName} ${person.lastName} a été ${cause} à ${person.age} ans, victime de l'insécurité à ${person.cityName}.`;
                    } else if (Math.random() < finalRates.generic) {
                        diedPrematurely = true;
                        const cause = genericPrematureDeathCauses[Math.floor(Math.random() * genericPrematureDeathCauses.length)];
                        causeOfDeathMessage = `💀 ${person.firstName} ${person.lastName} est décédé(e) prématurément à ${person.age} ans ${cause} à ${person.cityName}.`;
                    }

                    if (diedPrematurely) {
                        logEvent(causeOfDeathMessage, person.cityId, person.familyId);
                        died = true;
                    }
                }

                if (died) {
                    person.isAlive = false;
                    person.job = null;
                    if (person.spouseId !== null) {
                        const spouse = simulation.population.find(p => p.id === person.spouseId);
                        if (spouse) {
                            spouse.spouseId = null;
                            spouse.wasMarried = true;
                        }
                    }
                }
            });
        }
        
        function checkForFamilyExtinction() {
            for (const familyId in simulation.families) {
                const family = simulation.families[familyId];
                if (!family || !family.members || family.isExtinct) continue;

                const members = family.members.map(id => simulation.population.find(p => p.id === id)).filter(Boolean);
                const hasLivingMaleHeir = members.some(p => p.isAlive && p.gender === 'M' && p.lastName === family.originalName);

                if (!hasLivingMaleHeir) {
                    const region = getCurrentRegion();
                    const city = region.cities.find(c => c.name === family.location);
                    const cityId = city ? city.id : null;

                    let message = `☠️ La lignée des <strong>${family.originalName}</strong> dans <strong>${family.location}</strong> s'est éteinte, n'ayant plus d'héritier mâle.`;
                    
                    const allPeopleWithFamilyName = simulation.population.filter(p => 
                        p.isAlive && (p.lastName === family.originalName || p.maidenName === family.originalName));
                    const otherCities = [...new Set(allPeopleWithFamilyName.map(p => p.cityName).filter(cityName => cityName !== family.location))];

                    if (otherCities.length > 0) {
                        message += ` Mais reste de la famille dans le ou les lieux "${otherCities.join('", "')}".`;
                    }
                    logEvent(message, cityId, familyId);
                    family.isExtinct = true;
                }
            }
        }

        function handleBirths() {
            const newChildren = [];
            const couples = simulation.population.filter(p => p.isAlive && p.gender === 'M' && p.spouseId !== null);
            couples.forEach(father => {
                const mother = simulation.population.find(p => p.id === father.spouseId);
                if (!mother || !mother.isAlive) return;
                const raceInfo = simulation.races[mother.race];
                if (!raceInfo) return;
                const fertilityEndAge = raceInfo.lifespan * 0.55;
                if (mother.age >= raceInfo.adultAge && mother.age < fertilityEndAge) {
                    const maxFertilityChance = 0.20; 
                    const fertilityRange = fertilityEndAge - raceInfo.adultAge;
                    const yearsIntoFertility = mother.age - raceInfo.adultAge;
                    const fertilityProgress = yearsIntoFertility / fertilityRange;
                    const currentBirthChance = maxFertilityChance * (1 - fertilityProgress);
                    
                    if(Math.random() < currentBirthChance) {
                        const childAge = 0;
                        const childRace = Math.random() < 0.5 ? father.race : mother.race;
                        const childGender = Math.random() < 0.5 ? 'M' : 'F';
                        const child = createPerson(childRace, father.lastName, father.familyId, childGender, childAge, father.cityId, father.cityName, [father.id, mother.id]);
                        if(child){
                            father.children.push(child.id);
                            mother.children.push(child.id);
                            if (simulation.families[child.familyId]) {
                                simulation.families[child.familyId].members.push(child.id);
                            }
                            newChildren.push(child);
                            logEvent(`👶 Un enfant, ${child.firstName}, est né dans la famille ${father.lastName}.`, father.cityId, father.familyId);
                        }
                    }
                }
            });
            simulation.population.push(...newChildren);
        }
        
        function handleMarriages() {
            const MARRIAGE_SEARCH_CHANCE = 0.6; 
            const FOREIGN_MARRIAGE_CHANCE = 0.25; 

            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;
            const singleMen = simulation.population.filter(p => p.isAlive && p.spouseId === null && p.gender === 'M' && p.age >= (simulation.races[p.race]?.adultAge || 18));
            let singleWomen = simulation.population.filter(p => p.isAlive && p.spouseId === null && p.gender === 'F' && p.age >= (simulation.races[p.race]?.adultAge || 18));
            
            singleMen.forEach(man => {
                if (man.spouseId || Math.random() > MARRIAGE_SEARCH_CHANCE) return;

                const filterConditions = woman => {
                    if (woman.spouseId || woman.familyId === man.familyId) return false;
                    return Math.abs(man.age - woman.age) <= 5;
                };

                let suitableWives = singleWomen.filter(woman => woman.cityId === man.cityId && filterConditions(woman));
                
                if (suitableWives.length === 0 && Math.random() < FOREIGN_MARRIAGE_CHANCE) {
                    const manCity = currentRegion.cities.find(c => c.id === man.cityId);
                    if (!manCity) return;
                    const influenceToRadius = { 'local': 1, 'grand': 3, 'regional': 100 };
                    const manInfluence = influenceToRadius[manCity.config?.market_influence] || 1;

                    suitableWives = singleWomen.filter(woman => {
                        if (woman.cityId === man.cityId || !filterConditions(woman)) return false;
                        
                        const womanCity = currentRegion.cities.find(c => c.id === woman.cityId);
                        if (!womanCity) return false;

                        const womanInfluence = influenceToRadius[womanCity.config?.market_influence] || 1;
                        const distInHexes = cubeDistance(offsetToCube(manCity.q, manCity.r), offsetToCube(womanCity.q, womanCity.r));
                        return distInHexes <= manInfluence || distInHexes <= womanInfluence;
                    });
                }
                
                if (suitableWives.length > 0) {
                    const woman = suitableWives[Math.floor(Math.random() * suitableWives.length)];
                    
                    const originalWomanLastName = woman.lastName;
                    const oldFamilyId = woman.familyId;
                    man.spouseId = woman.id;
                    woman.spouseId = man.id;
                    woman.maidenName = woman.lastName;
                    woman.lastName = man.lastName;
                    
                    let marriageLog = `⚭ ${man.firstName} ${man.lastName} et ${woman.firstName} ${woman.lastName} (née ${originalWomanLastName}) se sont mariés.`;
                    if (man.wasMarried || woman.wasMarried) {
                        const secondTimers = [];
                        if (man.wasMarried) secondTimers.push("l'époux");
                        if (woman.wasMarried) secondTimers.push("l'épouse");
                        marriageLog += ` (Il s'agit d'un second mariage pour ${secondTimers.join(' et ')}).`;
                    }
                    logEvent(marriageLog, woman.cityId, man.familyId);
                    logEvent(marriageLog, woman.cityId, oldFamilyId);

                    const newFamilyId = man.familyId;
                    if (oldFamilyId !== newFamilyId) {
                        woman.familyId = newFamilyId;
                        if (simulation.families[oldFamilyId]) {
                            simulation.families[oldFamilyId].members = simulation.families[oldFamilyId].members.filter(id => id !== woman.id);
                        }
                        if (simulation.families[newFamilyId]) {
                            simulation.families[newFamilyId].members.push(woman.id);
                        }
                    }

                    if (man.cityId !== woman.cityId) {
                        handleRelocation(man, woman, { type: 'marriage' });
                    }

                    singleWomen = singleWomen.filter(w => w.id !== woman.id);
                }
            });
        }
        
        function handleRelocation(person1, person2, reason) {
            let personToMove, targetCity;

            if (reason.type === 'marriage') {
                const cityTiers = { 'Capitale': 1, 'Ville': 2, 'Village': 3, 'Hameau': 4, 'Donjon': 5 };
                const person1JobTier = person1.job?.tier || 99;
                const person2JobTier = person2.job?.tier || 99;
                const person1City = getCurrentRegion().cities.find(c=>c.id === person1.cityId);
                const person2City = getCurrentRegion().cities.find(c=>c.id === person2.cityId);
                if (!person1City || !person2City) return;
                const person1CityTier = cityTiers[person1City.type] || 99;
                const person2CityTier = cityTiers[person2City.type] || 99;

                if (person1JobTier < person2JobTier - 1) { personToMove = person2; targetCity = person1City; } 
                else if (person2JobTier < person1JobTier - 1) { personToMove = person1; targetCity = person2City; } 
                else if (person1CityTier < person2CityTier) { personToMove = person2; targetCity = person1City; } 
                else { personToMove = person1; targetCity = person2City; }
            } else if (reason.type === 'opportunity') {
                personToMove = person1;
                targetCity = reason.destinationCity;
                personToMove.yearsSinceMigration = 0;
            } else {
                return;
            }
            
            const oldCityName = personToMove.cityName;
            const oldJob = personToMove.job;
            const oldJobText = oldJob ? `quittant son poste de ${oldJob.role}` : 'qui était sans emploi';
            let logMessage = '';

            if (reason.type === 'marriage') {
                const spouse = (personToMove.id === person1.id) ? person2 : person1;
                logMessage = `✈️ Pour rejoindre son/sa conjoint(e) ${spouse.firstName} ${spouse.lastName}, ${personToMove.firstName} ${personToMove.lastName} a déménagé de ${oldCityName} à ${targetCity.name}, ${oldJobText}.`;
            } else if (reason.type === 'opportunity') {
                logMessage = `✨ En quête d'opportunités, ${personToMove.firstName} ${personToMove.lastName} a déménagé de ${oldCityName} à ${targetCity.name}, ${oldJobText}.`;
            }

            personToMove.cityId = targetCity.id;
            personToMove.cityName = targetCity.name;
            personToMove.job = null;
            
            if (personToMove.gender === 'M' && simulation.families[personToMove.familyId]) {
                simulation.families[personToMove.familyId].location = targetCity.name;
            }

            const eventMeta = reason.type === 'opportunity' ? { personId: personToMove.id } : {};
            logEvent(logMessage, targetCity.id, personToMove.familyId, eventMeta);
        }

        function handleEconomicMigration() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;

            const cityScores = {};

            currentRegion.cities.forEach(city => {
                const statusMultipliers = { 'prospere': 1.5, 'stable': 1.0, 'difficulte': 0.7, 'declin': 0.4 };
                const marketMultipliers = { 'regional': 1.3, 'grand': 1.1, 'local': 1.0 };
                let score = 1.0;
                score *= statusMultipliers[city.config?.city_status] || 1.0;
                score *= marketMultipliers[city.config?.market_influence] || 1.0;

                const filledJobs = {};
                simulation.population.forEach(p => {
                    if (p.isAlive && p.job && p.cityId === city.id) {
                        filledJobs[p.job.role] = (filledJobs[p.job.role] || 0) + 1;
                    }
                });

                let vacantHighTierJobs = 0;
                const requiredJobs = [...(jobData.base_jobs[city.type] || []), ...(Object.values(jobData.building_jobs).flat())];
                requiredJobs.forEach(jobInfo => {
                    if (jobInfo.tier <= 2) {
                        const needed = (jobInfo.quantity || 1) - (filledJobs[jobInfo.role] || 0);
                        if (needed > 0) vacantHighTierJobs += needed;
                    }
                });
                score += vacantHighTierJobs * 0.25;
                cityScores[city.id] = { score: score, city: city };
            });

            const potentialMigrants = simulation.population.filter(p => {
                const raceInfo = simulation.races[p.race];
                return p.isAlive && raceInfo && p.age > raceInfo.adultAge && (!p.job || (p.job.tier && p.job.tier >= 4));
            });
            
            potentialMigrants.forEach(person => {
                const personCity = currentRegion.cities.find(c => c.id === person.cityId);
                if (!personCity) return;
                const personCityStatus = personCity.config?.city_status || 'stable';
                
                const MIGRATION_CHECK_CHANCES = {
                    'prospere': 0.005,
                    'stable':   0.01,
                    'difficulte': 0.04,
                    'declin':   0.08
                };
                
                if (Math.random() < (MIGRATION_CHECK_CHANCES[personCityStatus] || 0.01)) {
                    const currentCityScore = cityScores[person.cityId]?.score || 0;
                    let bestAlternative = null;

                    for (const cityId in cityScores) {
                        if (cityId !== person.cityId) {
                            const destinationCity = cityScores[cityId].city;
                            const kmPerHex = getCurrentRegion()?.hexDistance || 10;
                            const distInHexes = cubeDistance(offsetToCube(personCity.q, personCity.r), offsetToCube(destinationCity.q, destinationCity.r));
                            const distInKm = distInHexes * kmPerHex;
                            
                            const perceivedScore = cityScores[cityId].score * (1 - (distInKm * 0.02));

                            if (perceivedScore > currentCityScore * 1.2) { 
                                if (!bestAlternative || perceivedScore > bestAlternative.score) {
                                    bestAlternative = {score: perceivedScore, city: destinationCity};
                                }
                            }
                        }
                    }
                    if (bestAlternative) {
                        const chance = (bestAlternative.score - currentCityScore) / bestAlternative.score;
                        if (Math.random() < chance) {
                            handleRelocation(person, null, { type: 'opportunity', destinationCity: bestAlternative.city });
                        }
                    }
                }
            });
        }
        
        function displayPopulation() {
            const popDisplay = document.getElementById('population-display');
            if (!popDisplay) return;

            const activeMainTab = popDisplay.querySelector(':scope > .tab-nav > .tab-button.active');
            const activeMainTabId = activeMainTab ? activeMainTab.dataset.tabId : 'population';

            let activeSubTabCityId = null;
            if (activeMainTab) {
                const activeMainPanelId = `tab-panel-${activeMainTabId}`;
                const activeMainPanel = document.getElementById(activeMainPanelId);
                if (activeMainPanel) {
                    const activeSubTab = activeMainPanel.querySelector('.tab-nav .tab-button.active');
                    if (activeSubTab) {
                        activeSubTabCityId = activeSubTab.dataset.cityId;
                    }
                }
            }

            const modalTitle = document.getElementById('population-modal-title');
            const historyContent = document.getElementById('history-log-content');
            const tabNav = popDisplay.querySelector(':scope > .tab-nav');
            const tabPanels = popDisplay.querySelector(':scope > .tab-panels');
            
            if (!modalTitle || !historyContent || !tabNav || !tabPanels) return;
            
            tabNav.innerHTML = '';
            tabPanels.innerHTML = '';
            
            const totalPopulation = simulation.population.filter(p => p.isAlive).length;
            modalTitle.textContent = `Population de la Région (Année ${simulation.year}) - ${totalPopulation} habitants`;
            
            historyContent.innerHTML = simulation.eventLog
                .slice().reverse().map(entry => `<p>${entry.message}</p>`).join('');
            historyContent.scrollTop = 0;
            
            const currentRegion = getCurrentRegion();
            if (!currentRegion || !currentRegion.cities) return;
            const citiesData = [...currentRegion.cities];

            const mainTabs = [{id: 'population', text: 'Population'}, {id: 'evolution', text: 'Évolution du Lieu'}];
            mainTabs.forEach(mainTab => {
                 const tabButton = document.createElement('button');
                 tabButton.className = 'tab-button';
                 tabButton.dataset.tabId = mainTab.id;
                 tabButton.textContent = mainTab.text;
                 tabNav.appendChild(tabButton);

                 const tabPanel = document.createElement('div');
                 tabPanel.className = 'tab-panel';
                 tabPanel.id = `tab-panel-${mainTab.id}`;
                 tabPanel.innerHTML = `<div class="tab-nav"></div><div class="tab-panels"></div>`;
                 tabPanels.appendChild(tabPanel);
                 
                 tabButton.addEventListener('click', () => {
                    popDisplay.querySelectorAll(':scope > .tab-nav > .tab-button').forEach(btn => btn.classList.remove('active'));
                    popDisplay.querySelectorAll(':scope > .tab-panels > .tab-panel').forEach(panel => panel.classList.remove('active'));
                    tabButton.classList.add('active');
                    tabPanel.classList.add('active');
                 });
            });

            citiesData.sort((a, b) => a.name.localeCompare(b.name)).forEach(cityData => {
                const cityPopulationCount = simulation.population.filter(p => p.isAlive && p.cityId === cityData.id).length;
                
                const popTabPanel = document.getElementById('tab-panel-population');
                const popSubTabNav = popTabPanel.querySelector('.tab-nav');
                const popSubTabPanels = popTabPanel.querySelector('.tab-panels');
                const popSubTabBtn = document.createElement('button');
                popSubTabBtn.className = 'tab-button';
                popSubTabBtn.dataset.cityId = cityData.id;
                popSubTabBtn.textContent = `${cityData.name} (${cityPopulationCount} hab.)`;
                popSubTabNav.appendChild(popSubTabBtn);
                const popSubTabPanel = document.createElement('div');
                popSubTabPanel.className = 'tab-panel';
                popSubTabPanel.id = `pop-subpanel-${cityData.id}`;
                popSubTabPanel.innerHTML = `<div class="tab-panel-content">${generateCityPopulationHtml(cityData)}</div>`;
                popSubTabPanels.appendChild(popSubTabPanel);
                popSubTabBtn.addEventListener('click', () => {
                    popSubTabNav.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    popSubTabPanels.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
                    popSubTabBtn.classList.add('active');
                    popSubTabPanel.classList.add('active');
                });

                const evoTabPanel = document.getElementById('tab-panel-evolution');
                const evoSubTabNav = evoTabPanel.querySelector('.tab-nav');
                const evoSubTabPanels = evoTabPanel.querySelector('.tab-panels');
                const evoSubTabBtn = document.createElement('button');
                evoSubTabBtn.className = 'tab-button';
                evoSubTabBtn.dataset.cityId = cityData.id;
                evoSubTabBtn.textContent = `${cityData.name}`;
                evoSubTabNav.appendChild(evoSubTabBtn);
                const evoSubTabPanel = document.createElement('div');
                evoSubTabPanel.className = 'tab-panel';
                evoSubTabPanel.id = `evo-subpanel-${cityData.id}`;
                evoSubTabPanel.innerHTML = `<div class="tab-panel-content">${generateCityEvolutionHtml(cityData)}</div>`;
                evoSubTabPanels.appendChild(evoSubTabPanel);
                evoSubTabBtn.addEventListener('click', () => {
                    evoSubTabNav.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    evoSubTabPanels.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
                    evoSubTabBtn.classList.add('active');
                    evoSubTabPanel.classList.add('active');
                });
            });
            
            const mainTabToActivate = tabNav.querySelector(`[data-tab-id="${activeMainTabId}"]`) || tabNav.firstChild;
            if (mainTabToActivate) {
                mainTabToActivate.click();

                const mainPanelId = `tab-panel-${mainTabToActivate.dataset.tabId}`;
                const subTabContainer = document.getElementById(mainPanelId);

                if (subTabContainer) {
                    const subTabNav = subTabContainer.querySelector('.tab-nav');
                    if (subTabNav) {
                        const cityIdToActivate = activeSubTabCityId || (citiesData[0] ? citiesData[0].id : null);
                        const subTabToActivate = subTabNav.querySelector(`[data-city-id="${cityIdToActivate}"]`) || subTabNav.querySelector('.tab-button');
                        if (subTabToActivate) {
                            subTabToActivate.click();
                        }
                    }
                }
            }


            populationModal.style.display = 'flex';

            const eventLog = simulation.eventLog;
            const birthCount = eventLog.filter(e => e.message.startsWith('👶')).length;
            const deathCount = eventLog.filter(e => e.message.startsWith('🕊️') || e.message.startsWith('💀')).length;
            const marriageCount = eventLog.filter(e => e.message.startsWith('⚭')).length;
            const marriageMigrationCount = eventLog.filter(e => e.message.startsWith('✈️')).length;
            const opportunityMigrationCount = eventLog.filter(e => e.message.startsWith('✨')).length;
            const totalMigrationCount = marriageMigrationCount + opportunityMigrationCount;

            statsBirthsEl.textContent = `Naissances : ${birthCount}`;
            statsDeathsEl.textContent = `Décès : ${deathCount}`;
            statsMarriagesEl.textContent = `Mariages : ${marriageCount}`;
            statsMigrationsEl.textContent = `Migrations : ${totalMigrationCount}`;
            statsMigMarriageEl.textContent = `↳ par mariage : ${marriageMigrationCount}`;
            statsMigOpportunityEl.textContent = `↳ par opportunité : ${opportunityMigrationCount}`;
        }

        function generateCityEvolutionHtml(cityData) {
            let html = '';

            const cityHistoryEvents = simulation.eventLog
                .filter(e => e.cityId === cityData.id && (e.message.startsWith('📈') || e.message.startsWith('📉') || e.message.startsWith('🏛️')))
                .slice()
                .reverse();

            if (cityHistoryEvents.length > 0) {
                html += `<details open>`;
                html += `<summary>Historique des infrastructures</summary>`;
                html += `<div class="family-history">`;
                html += `<ul>`;
                cityHistoryEvents.forEach(event => {
                    html += `<li><strong>Année ${event.year}:</strong> ${event.message}</li>`;
                });
                html += `</ul></div></details>`;
            }
            
            html += `<h3>Bâtiments et Emplois à ${cityData.name}</h3>`;
            
            const jobStatus = getCityJobStatus(cityData);
            
            jobStatus.buildings.forEach(building => {
                html += `<div class="evolution-section">
                            <h5>${building.name}</h5>
                            <ul>`;
                building.jobs.forEach(job => {
                    html += `<li><span class="job-name">${job.role}</span> <span class="job-count">${job.filled} / ${job.required}</span></li>`;
                });
                html += `   </ul>
                         </div>`;
            });
            
            if (jobStatus.guilds.length > 0) {
                 html += `<h3>Guildes</h3>`;
                 jobStatus.guilds.forEach(guild => {
                     html += `<div class="evolution-section">
                                <h5>${guild.name}</h5>
                                <ul>`;
                    guild.jobs.forEach(job => {
                        html += `<li><span class="job-name">${job.role}</span> <span class="job-count">${job.filled} / ${job.required}</span></li>`;
                    });
                    html += `   </ul>
                             </div>`;
                 });
            }


            html += `<div class="evolution-section">
                        <h5>Métiers Autonomes</h5>
                        <ul>`;
            jobStatus.autonomous.forEach(job => {
                 html += `<li><span class="job-name">${job.role}</span> <span class="job-count">${job.filled}</span></li>`;
            });
            html += `   </ul>
                     </div>`;
            
            return html;
        }

        function generateCityPopulationHtml(cityData) {
             let cityHtml = '';
            const familiesInCity = Object.values(simulation.families).filter(family => {
                const familyId = Object.keys(simulation.families).find(id => simulation.families[id] === family);
                return simulation.population.some(p => p.isAlive && p.cityId === cityData.id && p.familyId === familyId);
            });
            
            familiesInCity.sort((a,b) => a.originalName.localeCompare(b.originalName)).forEach(familyGroup => {
                const familyId = Object.keys(simulation.families).find(id => simulation.families[id] === familyGroup);
                const familyName = familyGroup.originalName;
                const familyMembersInCity = simulation.population.filter(p => p.familyId === familyId && p.cityId === cityData.id);
                const hasLivingMembers = familyMembersInCity.some(p => p.isAlive);
                
                const familyHistory = simulation.eventLog.filter(e => e.familyId === familyId);
                const validEvents = familyHistory.slice().reverse().filter(e => e.message.replace(/<\/?h3>/g, '').trim());

                if (hasLivingMembers) {
                    cityHtml += `<details open><summary>${familyName} ${familyGroup.isExtinct ? '(Lignée éteinte)' : ''}</summary>`;

                    if (validEvents.length > 0) {
                        const previewHtml = validEvents.slice(0, 3).map(event => {
                            const message = event.message.replace(/<\/?h3>/g, '').trim();
                            return `<li><strong>Année ${event.year}:</strong> ${message}</li>`;
                        }).join('');

                        const openModalButton = validEvents.length > 3
                            ? `<button class="open-history-modal-btn" data-family-id="${familyId}" data-family-name="${familyName}">Afficher tout l'historique (${validEvents.length} événements)</button>`
                            : '';

                        cityHtml += `<div class="family-history">
                                        <h5>Historique (récent)</h5>
                                        <div><ul>${previewHtml}</ul></div>
                                        ${openModalButton}
                                     </div>`;
                    }

                    const membersMap = new Map(familyMembersInCity.map(p => [p.id, p]));
                    const roots = familyMembersInCity.filter(p => p.isAlive && (!p.parents || p.parents.length === 0 || !p.parents.some(parentId => membersMap.has(parentId))));
                    const renderedIds = new Set();
                    
                    cityHtml += `<div class="family-tree"><ul>`;
                    roots.sort((a, b) => b.age - a.age).forEach(root => {
                         if (!renderedIds.has(root.id)) {
                            cityHtml += renderFamilyTree(root, membersMap, renderedIds);
                         }
                    });
                    cityHtml += `</ul></div>`;
                    cityHtml += `</details>`;
                }
            });

            const movedAwayFamilies = [];
            for (const familyId in simulation.families) {
                const family = simulation.families[familyId];
                if (family.location !== cityData.name && !family.isExtinct) {
                    const hasHistoryInCity = simulation.eventLog.some(e => e.familyId === familyId && e.cityId === cityData.id);
                    if (hasHistoryInCity) {
                        movedAwayFamilies.push(family);
                    }
                }
            }
            
            movedAwayFamilies.sort((a,b) => a.originalName.localeCompare(b.originalName)).forEach(family => {
                cityHtml += `<details><summary>${family.originalName} (Parti)</summary>
                                <div class="family-history family-history-moved">
                                    <p>La famille ${family.originalName} ne réside plus à ${cityData.name}.<br>
                                       Elle se trouve actuellement à : <strong>${family.location}</strong>.</p>
                                </div>
                             </details>`;
            });

            return cityHtml;
        }

        function renderFamilyTree(person, membersMap, renderedIds) {
            if (!person || renderedIds.has(person.id) || !person.isAlive) return '';

            renderedIds.add(person.id);
            
            let html = '<li>';
            const spouse = person.spouseId ? simulation.population.find(p => p.id === person.spouseId) : null;
            
            html += formatPerson(person);
            
            if (spouse && spouse.isAlive && spouse.cityId === person.cityId) {
                renderedIds.add(spouse.id);
                html += ' & ' + formatPerson(spouse);
            }
            
            const childrenIds = new Set(person.children);
            if(spouse) {
                spouse.children.forEach(id => childrenIds.add(id));
            }

            const children = Array.from(childrenIds)
                .map(id => membersMap.get(id))
                .filter(Boolean)
                .sort((a,b) => b.age - a.age);

            if (children.length > 0) {
                html += '<ul>';
                children.forEach(child => {
                    html += renderFamilyTree(child, membersMap, renderedIds);
                });
                html += '</ul>';
            }

            html += '</li>';
            return html;
        }

        function formatPerson(person) {
            const deadClass = person.isAlive ? '' : 'class="dead"';
            let nameDisplay = `<span ${deadClass}><b>${person.firstName} ${person.lastName}</b>`;
            if(person.maidenName) nameDisplay += ` <span class="maiden-name">(née ${person.maidenName})</span>`;
            nameDisplay += '</span>';

            let originInfo = '';
            if (person.originCityId && person.originCityId !== person.cityId) {
                originInfo = ` <span class="origin-info">(originaire de ${person.originCityName})</span>`;
            }

            const jobInfo = person.job ? ` - <span class="person-job">${person.job.role}</span>` : ' - Sans emploi';

            return `${nameDisplay} (${person.gender}, ${person.age} ans, ${person.race})${originInfo}${jobInfo}`;
        }

        // On lance l'initialisation de la page.
        initializePage();
    });
    </script>
</body>
</html>