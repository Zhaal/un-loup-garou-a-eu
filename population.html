<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Génération de la Population</title>
    <style>
        :root {
            --primary-color: #5a88ca;
            --primary-hover: #3d6fa1;
            --secondary-color: #f4f4f4;
            --border-color: #ddd;
            --text-dark: #333;
            --danger-color: #d00000;
            --success-color: #28a745;
            --job-color: #c97b0a;
            --save-color: #1e6e0f;
            --retired-color: #2a9d8f; /* AJOUT */
        }
        body {
            font-size: 16px;
            line-height: 1.6;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--secondary-color);
            margin: 0;
            padding: 20px;
            padding-left: 200px; /* AJOUT / MODIFICATION ICI */
            color: var(--text-dark);
            line-height: 1.6;
        }

        /* Floating Menu Styles */
        .floating-menu {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background-color: var(--primary-color);
            padding: 10px 0;
            border-radius: 0 8px 8px 0;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .floating-menu a {
            line-height: 1.3;
            white-space: normal;
            word-break: break-word;
            display: block;
            color: white;
            padding: 10px 15px;
            text-decoration: none;
            font-weight: 500;
            transition: background-color: 0.3s ease;
            white-space: nowrap;
        }

        .floating-menu a:hover {
            background-color: var(--primary-hover);
        }

        .floating-menu a.active {
            background-color: #e85d04; /* A distinct color for the active page */
            font-weight: bold;
        }

        .container {
            display: grid;
            grid-template-columns: 500px 1fr;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }
        #config-panel, #results-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3, h4 { color: var(--primary-color); }
        h2 { border-bottom: 1px solid var(--border-color); padding-bottom: 8px; margin-top: 0; }
        h3 { margin-top: 25px; }
        h4 { font-size: 1.1em; border-bottom: none; margin: 15px 0 10px; }
        h5 { font-size: 1.05em; color: #333; margin: 10px 0 5px 0;}
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; }
        input, select, textarea {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            box-sizing: border-box;
        }
        textarea { min-height: 80px; resize: vertical; }
        input[readonly] { background-color: #e9ecef; font-weight: bold; }
        
        button {
            background: var(--primary-color);
            color: white;
            cursor: pointer;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 1em;
            font-weight: 500;
        }
        button:hover { background: var(--primary-hover); }
        button:disabled { background: #cccccc; cursor: not-allowed; }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .button-group button {
            flex-grow: 1;
        }

        .race-management-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        #save-races-db-btn {
            background-color: var(--save-color);
        }
        
        .race-card {
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--primary-color);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        .race-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .race-card-header h4 { margin: 0; border: none; padding: 0; }
        .race-card-header .delete-race-btn {
            background-color: var(--danger-color);
            color: white;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }
        .grid-2-col { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        #total-percentage { font-weight: bold; text-align: right; margin-top: 10px; padding: 8px; border-radius: 4px; }
        
        #validation-checklist { margin-bottom: 20px; }
        #validation-checklist p { font-weight: bold; }
        #validation-checklist ul { list-style: none; padding: 0; margin-top: 10px; }
        #validation-checklist li {
            padding: 8px; margin-bottom: 5px; border-radius: 4px;
            transition: all 0.3s ease;
            border-left: 5px solid;
            font-size: 0.9em;
        }
        #validation-checklist li.valid {
            color: #155724;
            background-color: #d4edda;
            border-color: var(--success-color);
        }
        #validation-checklist li.invalid {
            color: #721c24;
            background-color: #f8d7da;
            border-color: var(--danger-color);
        }
        #validation-checklist li::before {
            font-weight: bold;
            margin-right: 10px;
        }
        #validation-checklist li.valid::before { content: '✔'; }
        #validation-checklist li.invalid::before { content: '❌'; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: none; justify-content: center;
            align-items: center; z-index: 1000;
        }
        .modal-content {
            background: white; padding: 25px; border-radius: 8px; width: 90%;
            max-width: 1600px; height: 90vh; display: flex; flex-direction: column;
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; }
        .modal-close { font-size: 2rem; cursor: pointer; font-weight: bold; }
        .modal-body {
            font-size: 16px;
            line-height: 1.6; 
            overflow: hidden;
            margin-top: 15px;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            flex-grow: 1;
        }
        #population-display, #history-log {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #history-log-content {
            overflow-y: auto;
            padding: 5px;
            flex-grow: 1;
        }
        #history-log-content p {
            font-size: 0.9em;
            margin: 0 0 8px 0;
            border-bottom: 1px dashed #eee;
            padding-bottom: 8px;
        }
        
        /* =============================================================== */
        /* == DEBUT DES CORRECTIONS POUR LA BARRE DE RECHERCHE DE PERSONNAGE == */
        /* =============================================================== */

        /* Le conteneur de la recherche doit être 'relatif' 
           pour que la liste de résultats se positionne par rapport à lui */
        #person-search-container {
            position: relative;
        }

        /* La liste de résultats est maintenant positionnée de manière 'absolue'
           pour flotter par-dessus le reste du contenu */
        #person-search-results {
            position: absolute;
            top: 100%; /* Se positionne juste en dessous de son parent (le conteneur de recherche) */
            left: 0;
            right: 0; /* Prend toute la largeur */
            z-index: 100; /* On s'assure qu'elle est bien au-dessus de tout */
            
            background: white;
            border: 1px solid #ddd;
            border-top: none; /* Esthétique : pas de double bordure */
            border-radius: 0 0 4px 4px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); /* Joli effet d'ombre */

            max-height: 250px; /* Hauteur maximale avant d'afficher une barre de défilement */
            overflow-y: auto;
            
            /* On retire les styles de liste par défaut */
            margin: 0;
            padding: 0;
            list-style: none;
        }

        #person-search-results li {
            padding: 5px 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }
        #person-search-results li:hover {
            background-color: #f0f8ff;
        }
        #person-search-results li:last-child {
            border-bottom: none;
        }
        
        /* =============================================================== */
        /* == FIN DES CORRECTIONS POUR LA BARRE DE RECHERCHE DE PERSONNAGE === */
        /* =============================================================== */


        #real-time-stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        #real-time-stats h4 {
            margin: 0 0 10px 0;
        }
        #real-time-stats ul {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 0.95em;
        }
        #real-time-stats li {
            margin-bottom: 5px;
        }
        #real-time-stats ul ul {
            padding-left: 20px;
            margin-top: 5px;
        }
        .tab-nav {
            display: flex;
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        .tab-button {
            padding: 10px 15px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 1em;
            color: var(--text-dark);
        }
        .tab-button.active {
            font-weight: bold;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            margin-bottom: -2px;
        }
        
        .tab-panels {
            flex-grow: 1;
            display: flex;
            overflow: hidden;
        }
        .tab-panel {
            display: none;
            flex-direction: column;
            flex-grow: 1;
            padding-top: 15px;
        }
        .tab-panel.active {
            display: flex;
        }
        .tab-panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
        }

        details { border: 1px solid #eee; border-radius: 4px; margin-bottom: 8px; }
        summary { padding: 10px; cursor: pointer; font-weight: bold; background: #f8f9fa; }
        
        .family-tree ul {
            list-style: none;
            padding-left: 25px;
            border-left: 1px solid #ccc;
        }
        .family-tree li {
            padding: 4px 0;
            line-height: 1.4;
            position: relative;
        }
        .family-tree li::before {
            content: '';
            position: absolute;
            top: 12px;
            left: -15px;
            width: 15px;
            height: 1px;
            background-color: #ccc;
        }

        .person-job {
            font-style: italic;
            color: var(--job-color);
        }
        /* AJOUT */
        .person-job.retired {
            color: var(--retired-color);
        }
        .dead {
            text-decoration: line-through;
            opacity: 0.6;
        }
        .maiden-name, .origin-info {
            font-style: italic;
            color: #666;
            font-size: 0.9em;
        }
        .family-history {
            background-color: #f0f3f5;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 5px 15px 15px 15px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        .family-history h5 {
            margin: 10px 0 5px 0;
            color: var(--primary-color);
            font-size: 1em;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .family-history ul {
            padding-left: 20px;
            margin: 5px 0;
            list-style-type: disc;
        }
        .family-history li {
             margin-bottom: 4px;
        }
        .family-history .open-history-modal-btn {
            font-size: 0.8em;
            padding: 3px 8px;
            margin-top: 10px;
            width: 100%;
            background-color: #6c757d;
        }
        .family-history-moved p {
            margin: 10px 0 5px 0;
            line-height: 1.5;
        }
        .evolution-section {
             margin-bottom: 20px;
        }
        .evolution-section ul {
            list-style: none;
            padding: 0;
        }
         .evolution-section li {
            padding: 5px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
        }
        .evolution-section li:last-child {
            border-bottom: none;
        }
         .job-name {
            font-weight: 500;
        }
         .job-count {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="floating-menu">
        <div style="color:white; font-weight:bold; text-align:center; margin-bottom:10px;">Menu</div>
        <a href="map.html" data-step="1">Étape 1<br><small>(Carte)</small></a>
        <a href="generator.html" data-step="2">Étape 2<br><small>(Configuration)</small></a>
        <a href="population.html" data-step="3">Étape 3<br><small>(Simulation)</small></a>
        <a href="#" data-step="4">Étape 4<br><small>(Exploiter les données)</small></a>
    </div>
    <div class="container">
       <div id="config-panel">
            <h2>Configuration de la Simulation</h2>
            <div class="control-group grid-2-col">
                <div>
                    <label>Année Actuelle</label>
                    <input type="text" id="current-year" value="Année 0" readonly>
                </div>
                <div>
                    <label>Familles Fondatrices (Total)</label>
                    <input type="text" id="total-families" value="0" readonly>
                </div>
            </div>
            <h3>Gestion des Races</h3>
            <div class="control-group">
                <label for="preset-race-select">Charger une race pré-définie</label>
                <div style="display: flex; gap: 10px;">
                    <select id="preset-race-select">
                        <option value="">-- Choisir une race --</option>
                    </select>
                    <button id="load-preset-race-btn" style="width: auto; flex-shrink: 0;">Charger</button>
                </div>
            </div>
            <div class="race-management-buttons">
                <button id="add-race-btn">+ Ajouter une Race (Manuelle)</button>
                <button id="save-races-db-btn">Sauvegarder les Races</button>
            </div>
            <div id="race-list"></div>
            <p id="total-percentage">Total des pourcentages : 0%</p>
        </div>
        <div id="results-panel">
            <h2>Lancement</h2>
            <div id="validation-checklist">
                <p>Pour lancer la simulation, veuillez remplir les conditions suivantes :</p>
                <ul>
                    <li id="check-percentage" class="invalid"></li>
                    <li id="check-families" class="invalid"></li>
                    <li id="check-races" class="invalid"></li>
                </ul>
            </div>
            <div class="button-group">
                <button id="start-simulation-btn" disabled>Lancer la Simulation (G0)</button>
                <button id="view-results-btn" disabled>Voir le Résultat</button>
            </div>
        </div>
    </div>
    
    <template id="race-card-template"><div class="race-card"><div class="race-card-header"><h4>Nouvelle Race</h4><button class="delete-race-btn">Supprimer</button></div><div class="control-group"><label>Nom de la Race</label><input type="text" class="race-name" placeholder="Ex: Humain"></div><div class="grid-2-col"><div class="control-group"><label>Espérance de vie</label><input type="number" class="race-lifespan" value="80" min="1"></div><div class="control-group"><label>Âge adulte</label><input type="number" class="race-adultage" value="18" min="1"></div></div><div class="grid-2-col"><div class="control-group"><label>Prénoms Masculins (séparés par virgule)</label><textarea class="race-firstnames-m" placeholder="Arthur, Lancelot, ..."></textarea></div><div class="control-group"><label>Prénoms Féminins (séparés par virgule)</label><textarea class="race-firstnames-f" placeholder="Guenièvre, Morgane, ..."></textarea></div></div><div class="control-group"><label>Noms de famille (séparés par virgule)</label><textarea class="race-lastnames" placeholder="Pendragon, De Leonis, ..."></textarea></div><div class="control-group"><label>Pourcentage de présence (%)</label><input type="number" class="race-percentage" value="0" min="0" max="100"></div></div></template>

    <div id="population-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h2 id="population-modal-title">Population de la Région</h2><span class="modal-close">&times;</span></div>
            <div id="population-modal-body" class="modal-body">
                <div id="population-display">
                    <div class="tab-nav"></div>
                    <div class="tab-panels"></div>
                </div>

                <div id="right-panel-container" style="display: flex; flex-direction: column; overflow: hidden;">

                    <div id="person-search-container">
                        <h3>Recherche de Personnage</h3>
                        <div class="control-group" style="margin-bottom: 10px;">
                            <input type="text" id="person-search-input" placeholder="Rechercher par nom...">
                        </div>
                        <ul id="person-search-results"></ul>
                    </div>

                    <div id="history-log">
                        <hr style="margin-bottom: 15px;">
                        <h3>Historique des Événements</h3>
                        <div id="history-log-content"></div>
                        <div id="real-time-stats">
                            <h4>Statistiques</h4>
                            <ul>
                                <li id="stats-births">Naissances : 0</li>
                                <li id="stats-deaths">Décès : 0</li>
                                <li id="stats-marriages">Mariages : 0</li>
                                <li id="stats-migrations">Migrations : 0
                                    <ul>
                                        <li id="stats-mig-marriage">↳ par mariage : 0</li>
                                        <li id="stats-mig-opportunity">↳ par opportunité : 0</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>

                </div>
                
                </div>
        </div>
    </div>

    <div id="history-modal" class="modal-overlay" style="z-index: 1001;">
        <div class="modal-content" style="max-width: 800px; height: 80vh;">
            <div class="modal-header">
                <h2 id="history-modal-title">Historique de la famille</h2>
                <span id="history-modal-close" class="modal-close">&times;</span>
            </div>
            <div id="history-modal-body" style="overflow-y: auto; padding: 15px;">
                </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Highlight active step in floating menu
        const currentPath = window.location.pathname.split('/').pop();
        const menuLinks = document.querySelectorAll('.floating-menu a');
        menuLinks.forEach(link => {
            if (link.getAttribute('href') === currentPath) {
                link.classList.add('active');
            }
        });

        // --- MISE EN CACHE DES ÉLÉMENTS DU DOM ---
        const totalFamiliesInput = document.getElementById('total-families');
        const addRaceBtn = document.getElementById('add-race-btn');
        const raceListDiv = document.getElementById('race-list');
        const raceCardTemplate = document.getElementById('race-card-template');
        const totalPercentageP = document.getElementById('total-percentage');
        const startSimBtn = document.getElementById('start-simulation-btn');
        const viewResultsBtn = document.getElementById('view-results-btn');
        const populationModal = document.getElementById('population-modal');
        const historyModal = document.getElementById('history-modal');
        const checkPercentEl = document.getElementById('check-percentage');
        const checkFamiliesEl = document.getElementById('check-families');
        const checkRacesEl = document.getElementById('check-races');
        const saveRacesBtn = document.getElementById('save-races-db-btn');
        const currentYearInput = document.getElementById('current-year');
        const presetRaceSelect = document.getElementById('preset-race-select');
        const loadPresetRaceBtn = document.getElementById('load-preset-race-btn');
        const statsBirthsEl = document.getElementById('stats-births');
        const statsDeathsEl = document.getElementById('stats-deaths');
        const statsMarriagesEl = document.getElementById('stats-marriages');
        const statsMigrationsEl = document.getElementById('stats-migrations');
        const statsMigMarriageEl = document.getElementById('stats-mig-marriage');
        const statsMigOpportunityEl = document.getElementById('stats-mig-opportunity');
        const personSearchInput = document.getElementById('person-search-input'); // AJOUT
        const personSearchResultsUl = document.getElementById('person-search-results'); // AJOUT

        // --- VARIABLES DE SIMULATION ---
        let allRegions = {};
        let simulation = {
            year: 0, population: [], families: {},
            races: {}, eventLog: []
        };
        
        // --- DONNÉES DE CONFIGURATION ---
        let PRESET_RACES = {};
        const guildData = {
            'Guilde des Artisans': {
                required_buildings: ['Forge', 'Menuisier / Charpentier', 'Tanneur / Maroquinier', 'Tisserand / Tailleur'],
                min_buildings: 2,
                min_pop: 100,
                master_role: 'Maître de la Guilde des Artisans',
                member_role: 'Artisan de Guilde',
            },
            'Guilde des Combattants': {
                required_buildings: ['Caserne / Garde', 'Murailles', 'Arène / Colisée'],
                min_buildings: 1,
                min_pop: 150,
                master_role: 'Maître de la Guilde des Combattants',
                member_role: 'Combattant de Guilde',
            },
            'Guilde des Érudits': {
                required_buildings: ['Bibliothèque / Scriptorium', 'Atelier de mage', "Échoppe d'alchimiste", 'Observatoire'],
                min_buildings: 1,
                min_pop: 250,
                master_role: 'Maître de la Guilde des Érudits',
                member_role: 'Érudit de Guilde',
            }
        };
        const jobData = {
            base_jobs: {
                'Hameau': [{ role: 'Chef(fe) de hameau', tier: 2, unique: true, quantity: 1 }],
                'Village': [{ role: 'Maire du village', tier: 2, unique: true, quantity: 1, promotes_from: ['Garde champêtre'] }, { role: 'Garde champêtre', tier: 3, quantity: 2 }],
                'Ville': [{ role: 'Maire', tier: 1, unique: true, quantity: 1, promotes_from: ['Capitaine de la garde', 'Magistrat'] }, { role: 'Capitaine de la garde', tier: 2, unique: true, quantity: 1, promotes_from: ['Sergent'], guild_affiliation: 'Guilde des Combattants' }, { role: 'Magistrat', tier: 2, unique: true, quantity: 1, promotes_from: ['Greffier'] }, { role: 'Greffier', tier: 3, quantity: 1 }],
                'Capitale': [{ role: 'Dirigeant(e)', tier: 1, unique: true, scope: 'region', quantity: 1, retires: false }, { role: 'Général(e) de la garde', tier: 1, unique: true, quantity: 1, promotes_from: ['Capitaine de la garde'] }, { role: 'Archiviste royal', tier: 2, unique: true, quantity: 1, promotes_from: ['Maître Bibliothécaire'], guild_affiliation: 'Guilde des Érudits' }, { role: 'Maître espion', tier: 2, unique: true, quantity: 1 }]
            },
            building_jobs: {
                'Taverne / Auberge': [ { role: 'Tavernier/ère', tier: 3, unique: true, quantity: 1 }, { role: 'Serveur/euse', tier: 4, dynamic_quantity_per_pop: 40 }, { role: 'Videur', tier: 4, dynamic_quantity_per_pop: 150 } ],
                'Forge': [ { role: 'Maître Forgeron', tier: 2, unique: true, quantity: 1, promotes_from: ['Apprenti(e) Forgeron'], guild_affiliation: 'Guilde des Artisans' }, { role: 'Apprenti(e) Forgeron', tier: 4, master: 'Maître Forgeron', quantity: 2, guild_source: 'Guilde des Artisans' } ],
                'Marché central': [ { role: 'Maître du marché', tier: 3, unique: true, quantity: 1 }, { role: 'Vendeur de stand', tier: 4, dynamic_quantity_per_pop: 30 } ],
                'Écuries': [ { role: 'Maître d\'écurie', tier: 3, unique: true, quantity: 1, promotes_from: ['Palefrenier'] }, { role: 'Palefenier', tier: 4, quantity: 4 } ],
                'Boulangerie': [ { role: 'Maître Boulanger', tier: 3, unique: true, quantity: 1, promotes_from: ['Mitron'], guild_affiliation: 'Guilde des Artisans' }, { role: 'Mitron', tier: 4, master: 'Maître Boulanger', quantity: 2, guild_source: 'Guilde des Artisans' } ],
                'Menuisier / Charpentier': [ { role: 'Maître Artisan', tier: 3, unique: true, quantity: 1, promotes_from: ['Compagnon'], guild_affiliation: 'Guilde des Artisans' }, { role: 'Compagnon', tier: 4, master: 'Maître Artisan', dynamic_quantity_per_pop: 80, guild_source: 'Guilde des Artisans' } ],
                'Tanneur / Maroquinier': [ { role: 'Maître Tanneur', tier: 3, unique: true, quantity: 1, promotes_from: ['Ouvrier du cuir'], guild_affiliation: 'Guilde des Artisans' }, { role: 'Ouvrier du cuir', tier: 4, master: 'Maître Tanneur', dynamic_quantity_per_pop: 100, guild_source: 'Guilde des Artisans' } ],
                'Herboristerie': [ { role: 'Herboriste', tier: 3, unique: true, quantity: 1 }, { role: 'Cueilleur', tier: 4, quantity: 2 } ],
                'Brasserie / Distillerie': [ { role: 'Maître Brasseur', tier: 3, unique: true, quantity: 1, promotes_from: ['Goûteur'], guild_affiliation: 'Guilde des Artisans' }, { role: 'Goûteur', tier: 4, master: 'Maître Brasseur', quantity: 2, guild_source: 'Guilde des Artisans' } ],
                'Tisserand / Tailleur': [ { role: 'Maître Tisserand', tier: 3, unique: true, quantity: 1, promotes_from: ['Couturier/ère'], guild_affiliation: 'Guilde des Artisans' }, { role: 'Couturier/ère', tier: 4, master: 'Maître Tisserand', dynamic_quantity_per_pop: 80, guild_source: 'Guilde des Artisans' } ],
                'Temple / Église': [ { role: 'Grand(e) Prêtre/Prêtresse', tier: 2, unique: true, quantity: 1, promotes_from: ['Acolyte', 'Soigneur du Temple'] }, { role: 'Gardien du Temple', tier: 3, dynamic_quantity_per_pop: 200 }, { role: 'Soigneur du Temple', tier: 3, dynamic_quantity_per_pop: 180 }, { role: 'Moine / Scribe du Temple', tier: 3, dynamic_quantity_per_pop: 250 }, { role: 'Acolyte', tier: 4, master: 'Grand(e) Prêtre/Prêtresse', dynamic_quantity_per_pop: 120 } ],
                'Caserne / Garde': [ { role: 'Sergent', tier: 3, dynamic_quantity_per_pop: 200, promotes_from: ['Soldat de la garde'], guild_affiliation: 'Guilde des Combattants' }, { role: 'Armurier de la garde', tier: 3, quantity: 1, guild_affiliation: 'Guilde des Artisans' }, { role: 'Soldat de la garde', tier: 4, master: 'Sergent', dynamic_quantity_per_pop: 50, guild_source: 'Guilde des Combattants' } ],
                'Château / Manoir': [ { role: 'Intendant(e)', tier: 2, unique: true, quantity: 1 }, { role: 'Chef Cuisinier', tier: 3, quantity: 1 }, { role: 'Garde du corps personnel', tier: 3, quantity: 4, guild_affiliation: 'Guilde des Combattants' }, { role: 'Maître des chasses', tier: 3, quantity: 1 }, { role: 'Domestique', tier: 5, dynamic_quantity_per_pop: 40 } ],
                'Bibliothèque / Scriptorium': [ { role: 'Maître Bibliothécaire', tier: 2, unique: true, quantity: 1, promotes_from: ['Archiviste', 'Copiste / Scribe'], guild_affiliation: 'Guilde des Érudits' }, { role: 'Copiste / Scribe', tier: 3, master: 'Maître Bibliothécaire', quantity: 3, guild_source: 'Guilde des Érudits' }, { role: 'Archiviste', tier: 3, quantity: 1, guild_source: 'Guilde des Érudits' } ],
                "Échoppe d'alchimiste": [ { role: 'Maître Alchimiste', tier: 2, unique: true, quantity: 1, promotes_from: ["Assistant(e) Alchimiste"], guild_affiliation: 'Guilde des Érudits' }, { role: 'Assistant(e) Alchimiste', tier: 4, master: 'Maître Alchimiste', quantity: 1, guild_source: 'Guilde des Érudits' } ],
                'Atelier de mage': [ { role: 'Mage résident', tier: 2, unique: true, quantity: 1, promotes_from: ["Apprenti(e) mage"], guild_affiliation: 'Guilde des Érudits' }, { role: 'Apprenti(e) mage', tier: 4, master: 'Mage résident', quantity: 1, guild_source: 'Guilde des Érudits' } ],
                'Observatoire': [ { role: 'Astronome', tier: 2, unique: true, quantity: 1, guild_affiliation: 'Guilde des Érudits' } ],
                'Arène / Colisée': [ { role: 'Maître des jeux', tier: 2, unique: true, quantity: 1, promotes_from: ['Gladiateur'], guild_affiliation: 'Guilde des Combattants' }, { role: 'Gladiateur', tier: 3, quantity: 5, guild_source: 'Guilde des Combattants' }, { role: 'Soigneur de l\'arène', tier: 3, quantity: 1 } ]
            },
            autonomous_jobs: [ 
                { role: 'Chasseur / Piégeur', tier: 4 }, { role: 'Pêcheur', tier: 4 }, { role: 'Bûcheron / Charbonnier', tier: 4 }, 
                { role: 'Mineur / Carrier', tier: 4 }, { role: 'Fermier / Éleveur', tier: 4 }, { role: 'Messager', tier: 4 }, 
                { role: 'Barde / Ménestrel', tier: 3 }, { role: 'Mercenaire', tier: 3 }, { role: 'Éclaireur', tier: 3 }, 
                { role: 'Mendiant', tier: 5, isBeggar: true },
                // --- NOUVEAU TIERS 6 : PÈGRE ---
                { role: 'Voleur', tier: 6, isUnderworld: true },
                { role: 'Assassin', tier: 6, isUnderworld: true },
                { role: 'Charlatan', tier: 6, isUnderworld: true },
                { role: 'Bandit de grand chemin', tier: 6, isUnderworld: true },
                { role: 'Contrebandier', tier: 6, isUnderworld: true }
            ]
        };
        const DYNAMIC_BUILDING_TIERS = {
            TIER1: { threshold: 75, types: ["Boulangerie", "Forge", "Menuisier / Charpentier"] },
            TIER2: { threshold: 150, types: ["Taverne / Auberge", "Herboristerie", "Tisserand / Tailleur", "Tanneur / Maroquinier"] },
            TIER3: { threshold: 300, types: ["Temple / Église", "Brasserie / Distillerie"] }
        };

        // --- FONCTIONS ---
        function offsetToCube(q, r) { const x = q; const z = r - (q + (q & 1)) / 2; const y = -x - z; return { x, y, z }; }
        function cubeDistance(a, b) { return (Math.abs(a.x - b.x) + Math.abs(a.y - b.y) + Math.abs(a.z - b.z)) / 2; }
        
        function getOrdinal(n) {
            if (n === 1) return 'premier';
            if (n === 2) return 'second';
            const ordinals = ['premier', 'second', 'troisième', 'quatrième', 'cinquième', 'sixième'];
            if (n > 0 && n <= ordinals.length) return ordinals[n - 1];
            return `${n}ème`;
        }
        
        async function loadPresetRaces() {
            try {
                const response = await fetch('race.json');
                if (!response.ok) {
                    throw new Error(`Erreur HTTP! Statut: ${response.status}`);
                }
                PRESET_RACES = await response.json();
                console.log("Races pré-définies chargées avec succès !");
            } catch (error) {
                console.error("Impossible de charger le fichier race.json:", error);
                alert("ERREUR : Impossible de charger les données des races. Assurez-vous que le fichier 'race.json' est bien dans le dépôt GitHub.");
            }
        }

        async function initializePage() {
            await loadPresetRaces();
            loadAllRegions();
            totalFamiliesInput.value = calculateTotalFamilies();
            loadRacesFromDB();
            populatePresetRacesDropdown();
            updateUiState();
            addRaceBtn.addEventListener('click', () => createAndPopulateRaceCard());
            saveRacesBtn.addEventListener('click', saveRacesToDB);
            loadPresetRaceBtn.addEventListener('click', handleLoadPresetRace);
            startSimBtn.addEventListener('click', generateG0);
            viewResultsBtn.addEventListener('click', displayPopulation);
            populationModal.querySelector('.modal-close').addEventListener('click', () => {
                populationModal.style.display = 'none';
            });
            const historyModalClose = document.getElementById('history-modal-close');
            historyModalClose.addEventListener('click', () => {
                historyModal.style.display = 'none';
            });
            historyModal.addEventListener('click', (event) => {
                if (event.target === historyModal) {
                    historyModal.style.display = 'none';
                }
            });
            document.body.addEventListener('click', function(event) {
                if (event.target && event.target.classList.contains('open-history-modal-btn')) {
                    const button = event.target;
                    const familyId = button.dataset.familyId;
                    const familyName = button.dataset.familyName;
                    openHistoryModal(familyId, familyName);
                }
            });
            
            // AJOUT: Event listeners for search
            personSearchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase().trim();
                personSearchResultsUl.innerHTML = '';

                if (query.length < 2) {
                    return;
                }

                const matches = simulation.population.filter(p => {
                    const fullName = `${p.firstName} ${p.lastName}`.toLowerCase();
                    return fullName.includes(query);
                });

                matches.forEach(person => {
                    const li = document.createElement('li');
                    li.innerHTML = `${person.firstName} ${person.lastName} <i>(${person.isAlive ? person.age + ' ans' : 'Décédé(e)'}, ${person.cityName})</i>`;
                    li.dataset.personId = person.id;
                    personSearchResultsUl.appendChild(li);
                });
            });

            personSearchResultsUl.addEventListener('click', (e) => {
                const li = e.target.closest('li');
                if (li && li.dataset.personId) {
                    const personId = parseInt(li.dataset.personId, 10);
                    openPersonHistoryModal(personId);
                }
            });
        }
        
        function populatePresetRacesDropdown() {
            for (const raceName in PRESET_RACES) {
                const option = document.createElement('option');
                option.value = raceName;
                option.textContent = raceName;
                presetRaceSelect.appendChild(option);
            }
        }

        function handleLoadPresetRace() {
            const selectedRaceName = presetRaceSelect.value;
            if (selectedRaceName && PRESET_RACES[selectedRaceName]) {
                const existingNames = Array.from(document.querySelectorAll('.race-name')).map(input => input.value.trim().toLowerCase());
                if (existingNames.includes(selectedRaceName.toLowerCase())) {
                    alert(`La race "${selectedRaceName}" est déjà présente dans la liste.`);
                    return;
                }
                createAndPopulateRaceCard(PRESET_RACES[selectedRaceName]);
                updateUiState();
            }
            presetRaceSelect.value = "";
        }
        
        // AJOUT/MODIFICATION: Ouvre l'historique d'une personne spécifique avec beaucoup plus de détails.
        function openPersonHistoryModal(personId) {
            const person = simulation.population.find(p => p.id === personId);
            if (!person) return;

            const title = document.getElementById('history-modal-title');
            const body = document.getElementById('history-modal-body');

            title.textContent = `Historique de ${person.firstName} ${person.lastName}`;
            
            // --- Build Bio Section ---
            let bioHtml = '<h3>Biographie</h3><div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">';
            
            // Column 1
            bioHtml += '<div>';
            bioHtml += `<p><strong>Nom:</strong> ${person.firstName} ${person.lastName} ${person.maidenName ? `(née ${person.maidenName})` : ''}</p>`;
            bioHtml += `<p><strong>Statut:</strong> ${person.isAlive ? 'En vie' : `Décédé(e) à l'âge de ${person.age} ans`}</p>`;
            bioHtml += `<p><strong>Race:</strong> ${person.race}</p>`;
            bioHtml += `<p><strong>Âge actuel:</strong> ${person.isAlive ? person.age + ' ans' : 'N/A'}</p>`;
            bioHtml += `<p><strong>Résidence:</strong> ${person.cityName} ${person.originCityId !== person.cityId ? `(originaire de ${person.originCityName})` : ''}</p>`;
            bioHtml += '</div>';

            // Column 2
            bioHtml += '<div>';
            // Parents
            if (person.parents && person.parents.length > 0) {
                const parentNames = person.parents.map(id => {
                    const p = simulation.population.find(parent => parent.id === id);
                    return p ? `${p.firstName} ${p.lastName}` : 'Inconnu';
                }).join(' et ');
                bioHtml += `<p><strong>Parents:</strong> ${parentNames}</p>`;
            }
            // Spouse
            if (person.spouseId) {
                 const spouse = simulation.population.find(p => p.id === person.spouseId);
                 bioHtml += `<p><strong>Conjoint(e):</strong> ${spouse ? `${spouse.firstName} ${spouse.lastName}` : 'Inconnu'}</p>`;
            } else {
                 bioHtml += `<p><strong>Conjoint(e):</strong> Aucun(e)</p>`;
            }
            // Children
            if (person.children && person.children.length > 0) {
                const childrenNames = person.children.map(id => {
                    const c = simulation.population.find(child => child.id === id);
                    return c ? c.firstName : '';
                }).filter(Boolean).join(', ');
                 bioHtml += `<p><strong>Enfants:</strong> ${childrenNames || 'Aucun'}</p>`;
            } else {
                 bioHtml += `<p><strong>Enfants:</strong> Aucun</p>`;
            }
            bioHtml += '</div></div>';

            // --- Build Job History Section ---
            let jobsHtml = '<hr><h3>Carrière professionnelle</h3>';
            if (person.job || person.jobHistory.length > 0) {
                jobsHtml += '<ul>';
                // Current Job
                if (person.job) {
                    jobsHtml += `<li><strong>Actuel:</strong> ${formatPersonJob(person)}</li>`;
                }
                // Past Jobs
                if (person.jobHistory && person.jobHistory.length > 0) {
                    [...person.jobHistory].reverse().forEach(j => {
                        const duration = Math.max(1, j.endDate - j.startDate);
                        const yearText = duration > 1 ? 'ans' : 'an';
                        jobsHtml += `<li>${j.role} (de l'an ${j.startDate} à ${j.endDate}, pendant ${duration} ${yearText})</li>`;
                    });
                }
                jobsHtml += '</ul>';
            } else {
                jobsHtml += '<p>N\'a jamais eu d\'emploi formel.</p>';
            }

            // --- Build Life Events Section ---
            const personHistory = simulation.eventLog.filter(e => {
                if (!e.meta) return false;
                return e.meta.personId === person.id ||
                       (e.meta.person1Id && e.meta.person1Id === person.id) ||
                       (e.meta.person2Id && e.meta.person2Id === person.id) ||
                       (e.meta.affectedPersonIds && e.meta.affectedPersonIds.includes(person.id));
            }).slice().reverse();

            let eventsHtml = '<hr><h3>Événements marquants</h3>';
            if (personHistory.length > 0) {
                eventsHtml += `<ul class="family-history" style="list-style-type: none; padding-left: 0;">`;
                personHistory.forEach(event => {
                    const message = event.message.replace(/<\/?h3>/g, '').trim();
                    if (message) {
                        eventsHtml += `<li style="margin-bottom: 5px;"><strong>Année ${event.year}:</strong> ${message}</li>`;
                    }
                });
                eventsHtml += `</ul>`;
            } else {
                eventsHtml += `<p>Aucun événement spécifique enregistré pour cette personne.</p>`;
            }

            body.innerHTML = bioHtml + jobsHtml + eventsHtml;
            historyModal.style.display = 'flex';
        }


        function openHistoryModal(familyId, familyName) {
            const title = document.getElementById('history-modal-title');
            const body = document.getElementById('history-modal-body');
            title.textContent = `Historique de la famille ${familyName}`;
            const fullHistory = simulation.eventLog
                .filter(e => e.familyId === familyId)
                .slice()
                .reverse();
            const listHtml = fullHistory.map(event => {
                const message = event.message.replace(/<\/?h3>/g, '').trim();
                if (message) {
                    return `<li><strong>Année ${event.year}:</strong> ${message}</li>`;
                }
                return '';
            }).join('');
            body.innerHTML = `<ul class="family-history">${listHtml}</ul>`;
            historyModal.style.display = 'flex';
        }

        function logEvent(message, cityId = null, familyId = null, meta = {}) {
            simulation.eventLog.push({
                year: simulation.year,
                cityId: cityId,
                familyId: familyId,
                message: message,
                meta: meta
            });
        }
        
        function saveRacesToDB() {
            const racesDB = {};
            document.querySelectorAll('.race-card').forEach(card => {
                const name = card.querySelector('.race-name').value.trim();
                if (!name) return;
                racesDB[name] = {
                    name: name,
                    lifespan: parseInt(card.querySelector('.race-lifespan').value),
                    adultAge: parseInt(card.querySelector('.race-adultage').value),
                    firstNamesM: card.querySelector('.race-firstnames-m').value,
                    firstNamesF: card.querySelector('.race-firstnames-f').value,
                    lastNames: card.querySelector('.race-lastnames').value
                };
            });
            localStorage.setItem('allRacesDB', JSON.stringify(racesDB));
            alert(`${Object.keys(racesDB).length} race(s) sauvegardée(s) !`);
        }

        function loadRacesFromDB() {
            const savedRaces = localStorage.getItem('allRacesDB');
            if (savedRaces) {
                const racesDB = JSON.parse(savedRaces);
                raceListDiv.innerHTML = '';
                if (Object.keys(racesDB).length > 0) {
                    Object.values(racesDB).forEach(raceData => {
                        createAndPopulateRaceCard(raceData);
                    });
                } else {
                    createAndPopulateRaceCard();
                }
            } else {
                createAndPopulateRaceCard();
            }
        }

        function createAndPopulateRaceCard(raceData = {}) {
            if (!raceCardTemplate) return;
            const cardClone = raceCardTemplate.content.cloneNode(true);
            const raceCard = cardClone.querySelector('.race-card');
            if (!raceCard) return;
            raceCard.querySelector('.race-name').value = raceData.name || '';
            raceCard.querySelector('h4').textContent = raceData.name || 'Nouvelle Race';
            raceCard.querySelector('.race-lifespan').value = raceData.lifespan || 80;
            raceCard.querySelector('.race-adultage').value = raceData.adultAge || 18;
            raceCard.querySelector('.race-firstnames-m').value = raceData.firstNamesM || '';
            raceCard.querySelector('.race-firstnames-f').value = raceData.firstNamesF || '';
            raceCard.querySelector('.race-lastnames').value = raceData.lastNames || '';
            raceCard.querySelector('.delete-race-btn').addEventListener('click', () => {
                raceCard.remove();
                updateUiState();
            });
            raceCard.querySelectorAll('input, textarea').forEach(el => {
                el.addEventListener('input', updateUiState);
            });
            raceListDiv.appendChild(cardClone);
        }

        function loadAllRegions() {
            const savedData = localStorage.getItem('allRegionsData');
            if (savedData) {
                allRegions = JSON.parse(savedData);
            } else {
                allRegions = {
                    currentRegionName: 'Ma Première Région',
                    regions: { 'Ma Première Région': { hexDistance: 10, cities: [] } }
                };
            }
        }

        function getCurrentRegion() {
            if (allRegions && allRegions.currentRegionName && allRegions.regions) {
                return allRegions.regions[allRegions.currentRegionName];
            }
            return null;
        }

        function calculateTotalFamilies() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion || !currentRegion.cities) return 0;
            return currentRegion.cities.reduce((total, city) => total + (city.config?.g0_families || 0), 0);
        }

        function updateUiState() {
            const percentages = Array.from(document.querySelectorAll('.race-percentage'));
            const total = percentages.reduce((sum, input) => sum + (parseFloat(input.value) || 0), 0);
            totalPercentageP.textContent = `Total des pourcentages : ${total}%`;
            checkPercentEl.textContent = `Le total des pourcentages des races doit être 100%. (Actuel: ${total}%)`;
            const percentValid = (total === 100);
            checkPercentEl.className = percentValid ? 'valid' : 'invalid';
            const g0families = parseInt(totalFamiliesInput.value);
            checkFamiliesEl.textContent = `Il doit y avoir au moins une famille fondatrice. (Actuel: ${g0families})`;
            const familiesValid = g0families > 0;
            checkFamiliesEl.className = familiesValid ? 'valid' : 'invalid';
            const racesValid = allRacesHaveData();
            checkRacesEl.textContent = `Toutes les fiches de race doivent être complètes (Nom, Prénoms M/F, Noms).`;
            checkRacesEl.className = racesValid ? 'valid' : 'invalid';
            startSimBtn.disabled = !(percentValid && familiesValid && racesValid);
        }
        
        function allRacesHaveData(){
            if (document.querySelectorAll('.race-card').length === 0) return false;
            return Array.from(document.querySelectorAll('.race-card')).every(card => {
                return card.querySelector('.race-name').value.trim() &&
                       card.querySelector('.race-firstnames-m').value.trim() &&
                       card.querySelector('.race-firstnames-f').value.trim() &&
                       card.querySelector('.race-lastnames').value.trim();
            });
        }

        function collectConfigData() {
            const raceCards = document.querySelectorAll('.race-card');
            const racesConfig = {};
            raceCards.forEach(card => {
                const name = card.querySelector('.race-name').value.trim();
                if (!name) return;
                racesConfig[name] = {
                    lifespan: parseInt(card.querySelector('.race-lifespan').value),
                    adultAge: parseInt(card.querySelector('.race-adultage').value),
                    firstNamesM: card.querySelector('.race-firstnames-m').value.split(',').map(n => n.trim()).filter(Boolean),
                    firstNamesF: card.querySelector('.race-firstnames-f').value.split(',').map(n => n.trim()).filter(Boolean),
                    lastNames: card.querySelector('.race-lastnames').value.split(',').map(n => n.trim()).filter(Boolean),
                    percentage: parseFloat(card.querySelector('.race-percentage').value)
                };
            });
            return racesConfig;
        }

        function weightedRandom(items) {
            const totalWeight = Object.values(items).reduce((sum, race) => sum + race.percentage, 0);
            let random = Math.random() * totalWeight;
            for (const name in items) {
                random -= items[name].percentage;
                if (random <= 0) { return name; }
            }
        }
        
        let nextPersonId = 0;
        let nextBuildingId = 0;
        function createPerson(raceName, familyName, familyId, gender, age = null, cityId, cityName, parents = []) {
            const raceInfo = simulation.races[raceName];
            if (!raceInfo) return null;
            const nameList = (gender === 'M') ? raceInfo.firstNamesM : raceInfo.firstNamesF;
            if (nameList.length === 0) return null;
            const personAge = age !== null ? age : Math.floor(Math.random() * 21) + 20;
            
            const baseRetirementAge = Math.floor(raceInfo.lifespan * 0.80);
            const variation = baseRetirementAge * 0.05; // 5% variation
            const personalRetirementAge = Math.floor(baseRetirementAge - variation + (Math.random() * variation * 2));

            return {
                id: nextPersonId++,
                firstName: nameList[Math.floor(Math.random() * nameList.length)],
                lastName: familyName,
                maidenName: null,
                age: personAge,
                gender: gender,
                race: raceName,
                isAlive: true,
                familyId: familyId,
                cityId: cityId,
                cityName: cityName,
                originCityId: cityId,
                originCityName: cityName,
                marriages: 0,
                job: null,
                jobHistory: [],
                parents: parents,
                spouseId: null,
                children: [],
                personalRetirementAge: personalRetirementAge,
                // --- AJOUTS POUR LE REMARIAGE ---
                widowedInYear: null,
                lastMarriageDuration: null,
                marriageStartDate: null,
                // --- NOUVEAU : SUIVI DE LA PRÉCARITÉ ---
                yearsUnemployed: 0,
                yearsAsBeggar: 0
            };
        }
        
        async function runFullSimulation() {
            startSimBtn.disabled = true;
            startSimBtn.textContent = 'Simulation en cours...';
            for (let i = 0; i < 100; i++) {
                advanceTime();
                displayPopulation();
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            logEvent(`<strong>FIN:</strong> La simulation s'est terminée après 100 ans.`, null, null);
            displayPopulation();
            startSimBtn.textContent = 'Simulation terminée';
        }

        function generateG0() {
            simulation.races = collectConfigData();
            simulation.population = [];
            simulation.families = {};
            simulation.eventLog = [];
            nextPersonId = 0;
            nextBuildingId = 0;
            simulation.year = 0;
            currentYearInput.value = 'Année 0';
            const currentRegion = getCurrentRegion();
            if(!currentRegion) return;
            currentRegion.cities.forEach(city => {
                if(!city.config) city.config = {};
                city.config.dynamic_buildings = [];
                city.config.guilds = [];
            });
            const familySlots = [];
            currentRegion.cities.forEach(city => {
                const numFamilies = city.config?.g0_families || 0;
                for (let i = 0; i < numFamilies; i++) {
                    familySlots.push({ cityId: city.id, cityName: city.name });
                }
            });
            familySlots.forEach((slot, index) => {
                const familyId = `F${index}`;
                const raceName = weightedRandom(simulation.races);
                if (!raceName) return;
                const raceInfo = simulation.races[raceName];
                const familyName = raceInfo.lastNames[Math.floor(Math.random() * raceInfo.lastNames.length)] || `Famille ${index}`;
                const age1 = Math.floor(Math.random() * 7) + 18;
                const minAge2 = Math.max(18, age1 - 5);
                const maxAge2 = Math.min(24, age1 + 5);
                const age2 = Math.floor(Math.random() * (maxAge2 - minAge2 + 1)) + minAge2;
                const person1 = createPerson(raceName, familyName, familyId, 'M', age1, slot.cityId, slot.cityName);
                const person2 = createPerson(raceName, familyName, familyId, 'F', age2, slot.cityId, slot.cityName);
                if (person1 && person2) {
                    person1.spouseId = person2.id;
                    person2.spouseId = person1.id;
                    person1.marriages = 1;
                    person2.marriages = 1;
                    person1.marriageStartDate = 0; // Mariage à l'année 0
                    person2.marriageStartDate = 0;
                    simulation.population.push(person1, person2);
                    simulation.families[familyId] = { 
                        originalName: familyName, 
                        members: [person1.id, person2.id],
                        location: slot.cityName
                    };
                }
            });
            assignJobs();
            simulation.population.forEach(p => { 
                if (p.job) {
                    p.job.startDate = 0;
                }
            });
            logEvent(`<strong>Année 0 :</strong> Fondation de la région avec ${simulation.population.length} personnes. Les premiers métiers ont été assignés.`, null, null);
            viewResultsBtn.disabled = false;
            displayPopulation();
            runFullSimulation();
        }
        
        function advanceTime() {
            simulation.year += 1;
            logEvent(`<h3>--- Année ${simulation.year} ---</h3>`, null, null);
            
            const currentRegion = getCurrentRegion();
            if (currentRegion) {
                currentRegion.cities.forEach(city => {
                    updateCityInfrastructure(city);
                    updateGuilds(city);
                    updateCityStatus(city); // NOUVEAU : Mise à jour du statut de la ville
                });
            }
            
            simulation.population.forEach(p => { if(p.isAlive) p.age += 1; });
            
            updatePrecarityAndUnderworld(); // NOUVEAU : Gère la mendicité et l'entrée dans la pègre
            
            simulation.population.forEach(p => {
                if (p.isAlive && p.yearsSinceMigration !== undefined) {
                    p.yearsSinceMigration++;
                }
            });
            
            handleDeaths();
            checkForFamilyExtinction();
            handleRetirement(); 
            handleMarriages();
            handleEconomicMigration();
            processMigrationImpact();
            handleBirths();
            assignJobs();
            currentYearInput.value = `Année ${simulation.year}`;
        }
        
        // --- NOUVELLES FONCTIONNALITÉS ---

        function updateCityStatus(city) {
            if (!city.config) return;

            const cityPopulation = simulation.population.filter(p => p.isAlive && p.cityId === city.id);
            if (cityPopulation.length === 0) return;

            // --- Facteurs de Dégradation ---
            const beggarCount = cityPopulation.filter(p => p.job?.isBeggar).length;
            const beggarPercentage = beggarCount / cityPopulation.length;
            let degradationChance = 0;
            // Si plus de 5% de la population est mendiante, le statut risque de se dégrader
            if (beggarPercentage > 0.05) {
                degradationChance = (beggarPercentage - 0.05) * 0.5; // La chance augmente avec le % de mendiants
            }

            // --- Facteurs d'Amélioration ---
            const guardJobs = ['Soldat de la garde', 'Sergent', 'Capitaine de la garde', 'Général(e) de la garde', 'Garde champêtre'];
            const guardCount = cityPopulation.filter(p => p.job && guardJobs.includes(p.job.role)).length;
            const tavernCount = cityPopulation.filter(p => p.job?.role === 'Tavernier/ère').length;
            
            const marketBuilding = city.config.buildings && city.config.buildings['Marché central'];
            let marketBonus = 0;
            if (marketBuilding) {
                const marketInfluence = city.config.market_influence || 'local';
                if (marketInfluence === 'local') marketBonus = 0.01;
                if (marketInfluence === 'grand') marketBonus = 0.03;
                if (marketInfluence === 'regional') marketBonus = 0.06;
            }

            let improvementChance = (guardCount * 0.005) + (tavernCount * 0.002) + marketBonus;

            // --- Application des changements ---
            const progression = ['prospere', 'stable', 'difficulte', 'declin'];
            const currentStatus = city.config.city_status || 'stable';
            const currentIndex = progression.indexOf(currentStatus);
            
            if (currentIndex === -1) return; // Statut invalide
            
            let newIndex = currentIndex;

            // On teste d'abord la dégradation, puis l'amélioration
            if (Math.random() < degradationChance) {
                newIndex = Math.min(progression.length - 1, currentIndex + 1);
            } else if (Math.random() < improvementChance) {
                newIndex = Math.max(0, currentIndex - 1);
            }

            if (newIndex !== currentIndex) {
                const newStatus = progression[newIndex];
                city.config.city_status = newStatus;
                logEvent(`⚖️ Le statut de <strong>${city.name}</strong> a changé de '${currentStatus}' à '${newStatus}'.`, city.id, null);
            }
        }

        function updatePrecarityAndUnderworld() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;

            const guardCounts = {};
            currentRegion.cities.forEach(city => {
                const cityPopulation = simulation.population.filter(p => p.isAlive && p.cityId === city.id);
                const guardJobs = ['Soldat de la garde', 'Sergent', 'Capitaine de la garde', 'Général(e) de la garde', 'Garde champêtre'];
                guardCounts[city.id] = cityPopulation.filter(p => p.job && guardJobs.includes(p.job.role)).length;
            });

            simulation.population.forEach(person => {
                if (!person.isAlive) return;

                // --- 1. Mise à jour des compteurs de précarité ---
                if (!person.job) {
                    person.yearsUnemployed = (person.yearsUnemployed || 0) + 1;
                    person.yearsAsBeggar = 0;
                } else if (person.job.isBeggar) {
                    person.yearsUnemployed = (person.yearsUnemployed || 0) + 1;
                    person.yearsAsBeggar = (person.yearsAsBeggar || 0) + 1;
                } else if (!person.job.isUnderworld) { // On ne réinitialise pas pour la pègre
                    person.yearsUnemployed = 0;
                    person.yearsAsBeggar = 0;
                }

                // --- 2. Chance de cesser d'être Mendiant ---
                if (person.job?.isBeggar) {
                    // La probabilité diminue avec le temps passé à mendier. Forcé après 5 ans.
                    const chanceToLeave = (0.3 / (person.yearsAsBeggar || 1));
                    if (Math.random() < chanceToLeave || person.yearsAsBeggar > 5) {
                        logEvent(`💪 ${person.firstName} ${person.lastName} a cessé de mendier.`, person.cityId, person.familyId, { personId: person.id });
                        person.job = null; // Devient 'sans emploi'
                        person.yearsAsBeggar = 0; // Réinitialisation
                    }
                }
                
                // --- 3. Chance de rejoindre la Pègre (Tiers 6) ---
                const canJoinUnderworld = (person.yearsAsBeggar >= 2 || person.yearsUnemployed >= 5) && !person.job?.isUnderworld;
                if (canJoinUnderworld) {
                    const city = currentRegion.cities.find(c => c.id === person.cityId);
                    if (!city || !city.config) return;

                    const cityStatus = city.config.city_status || 'stable';
                    const statusChanceMultipliers = { 'prospere': 0, 'stable': 0.01, 'difficulte': 0.1, 'declin': 0.25 };
                    let baseChance = statusChanceMultipliers[cityStatus] || 0;

                    // La chance est réduite par le nombre de gardes
                    const guardCount = guardCounts[city.id] || 0;
                    const securityFactor = 1 / (1 + (guardCount * 0.2)); // Chaque garde réduit la chance
                    const finalChance = baseChance * securityFactor;

                    if (Math.random() < finalChance) {
                        const underworldJobs = jobData.autonomous_jobs.filter(j => j.isUnderworld);
                        if (underworldJobs.length > 0) {
                            const newJob = underworldJobs[Math.floor(Math.random() * underworldJobs.length)];
                            person.job = {...newJob, startDate: simulation.year};
                            person.yearsUnemployed = 0; // Réinitialisation des compteurs
                            person.yearsAsBeggar = 0;
                            logEvent(`☠️ Poussé(e) par la précarité, ${person.firstName} ${person.lastName} a rejoint la pègre en tant que ${newJob.role}.`, city.id, person.familyId, { personId: person.id });
                        }
                    }
                }
            });
        }
        
        // --- FIN DES NOUVELLES FONCTIONNALITÉS ---

        // AJOUT: Nouvelle fonction pour gérer la retraite
        function handleRetirement() {
            simulation.population.forEach(person => {
                // Ne s'applique pas si mort, déjà retraité ou sans emploi.
                // Ne s'applique pas si le poste est un poste à vie.
                if (!person.isAlive || !person.job || person.job.isRetired || person.job.retires === false) return;

                // La condition utilise maintenant l'âge de retraite personnel
                if (person.age >= person.personalRetirementAge) {
                    const oldJob = person.job;
                    logEvent(`🧘 ${person.firstName} ${person.lastName} a pris sa retraite de son poste de ${oldJob.role} à ${person.age} ans.`, person.cityId, person.familyId, { personId: person.id });
                    
                    oldJob.endDate = simulation.year;
                    person.jobHistory.push(oldJob);
                    person.job = { role: 'Retraité(e)', tier: 99, isRetired: true, startDate: simulation.year };
                }
            });
        }

        function updateGuilds(city) {
            if (!city.config) return;
            const cityBuildings = new Set(Object.keys(city.config.buildings || {}).filter(b => city.config.buildings[b]));
            const cityPopulation = simulation.population.filter(p => p.isAlive && p.cityId === city.id).length;
            for (const [guildName, data] of Object.entries(guildData)) {
                const existingGuild = city.config.guilds.find(g => g.name === guildName);
                const buildingsOwned = [...cityBuildings].filter(b => data.required_buildings.includes(b)).length;
                if (!existingGuild && cityPopulation >= data.min_pop && buildingsOwned >= data.min_buildings) {
                    city.config.guilds.push({ name: guildName });
                    logEvent(`🏛️ La <strong>${guildName}</strong> a été fondée à ${city.name} !`, city.id, null);
                }
            }
        }

        function updateCityInfrastructure(city) {
            if (!city.config) return;
            const populationInCity = simulation.population.filter(p => p.isAlive && p.cityId === city.id).length;
            for (const tierInfo of Object.values(DYNAMIC_BUILDING_TIERS)) {
                if (populationInCity > tierInfo.threshold) {
                    const targetCount = Math.floor(populationInCity / tierInfo.threshold);
                    const currentCount = city.config.dynamic_buildings.filter(b => tierInfo.types.includes(b.name)).length;
                    if (targetCount > currentCount && Math.random() < 0.20) {
                        const newBuildingType = tierInfo.types[Math.floor(Math.random() * tierInfo.types.length)];
                        city.config.dynamic_buildings.push({ id: `bld_${nextBuildingId++}`, name: newBuildingType });
                        logEvent(`📈 Une nouvelle ${newBuildingType} a ouvert à ${city.name}.`, city.id, null);
                        break;
                    }
                }
            }
            for (const tierInfo of Object.values(DYNAMIC_BUILDING_TIERS)) {
                const targetCount = Math.floor(populationInCity / tierInfo.threshold);
                const buildingsOfType = city.config.dynamic_buildings.filter(b => tierInfo.types.includes(b.name));
                const currentCount = buildingsOfType.length;
                if (currentCount > targetCount && Math.random() < 0.15) {
                    const buildingToRemove = buildingsOfType[Math.floor(Math.random() * buildingsOfType.length)];
                    const employees = simulation.population.filter(p => p.job?.buildingInstanceId === buildingToRemove.id);
                    if (employees.length > 0) {
                        const employeeNames = employees.map(e => `${e.firstName} ${e.lastName} (${e.job.role})`).join(', ');
                        const employeeIds = employees.map(e => e.id); // MODIFICATION
                        logEvent(`📉 La ${buildingToRemove.name} de ${city.name} a fermé. Employés licenciés : ${employeeNames}.`, city.id, null, { affectedPersonIds: employeeIds }); // MODIFICATION
                        employees.forEach(e => { 
                            if(e.job) {
                                e.job.endDate = simulation.year;
                                e.jobHistory.push(e.job);
                                e.job = null;
                            }
                        });
                    } else {
                        logEvent(`📉 Une ${buildingToRemove.name} superflue a fermé à ${city.name}.`, city.id, null);
                    }
                    city.config.dynamic_buildings = city.config.dynamic_buildings.filter(b => b.id !== buildingToRemove.id);
                    break;
                }
            }
        }
        
        function getCityJobStatus(city) {
            const cityPopulation = simulation.population.filter(p => p.isAlive && p.cityId === city.id);
            const popCount = cityPopulation.length;
            const jobStatus = { buildings: [], guilds: [], autonomous: [] };
            const allBuildings = [
                ...Object.entries(city.config?.buildings || {}).filter(([, exists]) => exists).map(([name]) => ({ id: `static_${name.replace(/[^a-z]/gi, '')}`, name })), 
                ...(city.config?.dynamic_buildings || [])
            ];
            const filledJobs = cityPopulation.map(p => p.job).filter(Boolean);
            allBuildings.forEach(building => {
                const buildingInfo = { name: building.name, jobs: [] };
                const jobDefs = jobData.building_jobs[building.name] || [];
                jobDefs.forEach(def => {
                    let required = def.quantity || 0;
                    if (def.dynamic_quantity_per_pop) {
                        required += Math.floor(popCount / def.dynamic_quantity_per_pop);
                    }
                    if (required > 0) {
                        let filled;
                         if (building.id.startsWith('static')) {
                            filled = filledJobs.filter(j => j.role === def.role && !j.buildingInstanceId).length;
                         } else {
                            filled = filledJobs.filter(j => j.role === def.role && j.buildingInstanceId === building.id).length;
                         }
                        buildingInfo.jobs.push({ role: def.role, required, filled });
                    }
                });
                if(buildingInfo.jobs.length > 0) {
                   jobStatus.buildings.push(buildingInfo);
                }
            });
            (city.config.guilds || []).forEach(guild => {
                const guildDef = guildData[guild.name];
                if(guildDef) {
                    const masterFilled = filledJobs.filter(j => j.role === guildDef.master_role).length;
                    const membersFilled = filledJobs.filter(j => j.role === guildDef.member_role).length;
                    const memberRequired = Math.floor(popCount / 50);
                    jobStatus.guilds.push({
                        name: guild.name,
                        jobs: [
                            {role: guildDef.master_role, required: 1, filled: masterFilled},
                            {role: guildDef.member_role, required: memberRequired, filled: membersFilled}
                        ]
                    });
                }
            });
            jobData.autonomous_jobs.forEach(def => {
                const filled = filledJobs.filter(j => j.role === def.role).length;
                if (filled > 0 || !def.isBeggar) {
                    jobStatus.autonomous.push({ role: def.role, required: 'N/A', filled });
                }
            });
            return jobStatus;
        }

        function assignJobs() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;
            currentRegion.cities.forEach(city => {
                const populationInCity = simulation.population.filter(p => p.isAlive && p.cityId === city.id);
                const cityPopulationCount = populationInCity.length;
                if(cityPopulationCount === 0) return;
                let vacantJobs = [];
                let requiredJobsList = [];
                (jobData.base_jobs[city.type] || []).forEach(j => requiredJobsList.push({...j}));
                const allBuildings = [
                    ...Object.entries(city.config?.buildings || {}).filter(([, exists]) => exists).map(([name]) => ({ id: `static_${name.replace(/[^a-z]/gi, '')}`, name })), 
                    ...(city.config?.dynamic_buildings || [])
                ];
                allBuildings.forEach(building => {
                    (jobData.building_jobs[building.name] || []).forEach(jobDef => {
                        let quantity = jobDef.quantity || 0;
                        if(jobDef.dynamic_quantity_per_pop) quantity += Math.floor(cityPopulationCount / jobDef.dynamic_quantity_per_pop);
                        for(let i=0; i<quantity; i++) requiredJobsList.push({...jobDef, buildingInstanceId: building.id.startsWith('bld_') ? building.id : undefined });
                    });
                });
                (city.config.guilds || []).forEach(guild => {
                    const guildDef = guildData[guild.name];
                    if (guildDef) {
                        requiredJobsList.push({ role: guildDef.master_role, tier: 2 });
                        const memberCount = Math.floor(cityPopulationCount / 50);
                        for (let i = 0; i < memberCount; i++) {
                            requiredJobsList.push({ role: guildDef.member_role, tier: 3, isGuildMember: true, guildName: guild.name });
                        }
                    }
                });
                const filledJobCounts = {};
                populationInCity.forEach(p => {
                    if (p.job) {
                        const key = p.job.buildingInstanceId ? `${p.job.role}_${p.job.buildingInstanceId}` : p.job.role;
                        filledJobCounts[key] = (filledJobCounts[key] || 0) + 1;
                    }
                });
                 const requiredJobCounts = {};
                 requiredJobsList.forEach(jobInfo => {
                    const key = jobInfo.buildingInstanceId ? `${jobInfo.role}_${jobInfo.buildingInstanceId}` : jobInfo.role;
                    requiredJobCounts[key] = (requiredJobCounts[key] || 0) + 1;
                });
                for(const key in requiredJobCounts) {
                    const needed = requiredJobCounts[key] - (filledJobCounts[key] || 0);
                    if(needed > 0) {
                        const jobTemplate = requiredJobsList.find(j => (j.buildingInstanceId ? `${j.role}_${j.buildingInstanceId}` : j.role) === key);
                        for(let i=0; i<needed; i++) vacantJobs.push({...jobTemplate});
                    }
                }
                vacantJobs.sort((a, b) => (a.tier || 99) - (b.tier || 99));
                let availableCandidates = populationInCity.filter(p => !p.job);
                vacantJobs.forEach(vacantJob => {
                    if (availableCandidates.length === 0 && !vacantJob.promotes_from && !vacantJob.guild_affiliation) return;
                    let candidate = null, isPromotion = false, promotionSource = '';
                    if (vacantJob.promotes_from) {
                        const promotionCandidates = populationInCity.filter(p => p.job && vacantJob.promotes_from.includes(p.job.role)).sort((a,b) => b.age - a.age); 
                        if(promotionCandidates.length > 0) {
                            candidate = promotionCandidates[0];
                            isPromotion = true;
                            promotionSource = `son poste de ${candidate.job.role}`;
                        }
                    }
                    if (!candidate && vacantJob.guild_affiliation) {
                        const guildDef = guildData[vacantJob.guild_affiliation];
                        if (guildDef) {
                            const guildMembers = populationInCity.filter(p => p.job?.role === guildDef.member_role);
                            if (guildMembers.length > 0) {
                                guildMembers.sort((a,b) => b.age - a.age);
                                candidate = guildMembers[0];
                                isPromotion = true;
                                promotionSource = `la ${vacantJob.guild_affiliation}`;
                            }
                        }
                    }
                    if (!candidate) {
                        if(availableCandidates.length === 0) return;
                        let hirePool = availableCandidates.filter(p => p.age >= (simulation.races[p.race]?.adultAge || 18));
                        if (vacantJob.guild_source) {
                            const guildDef = guildData[vacantJob.guild_source];
                            if(guildDef) {
                                const guildPool = hirePool.filter(p => p.job?.role === guildDef.member_role);
                                if(guildPool.length > 0) hirePool = guildPool;
                            }
                        }
                        if (vacantJob.tier <= 3) {
                             const qualifiedPool = hirePool.filter(p => p.age > 25);
                             if (qualifiedPool.length > 0) hirePool = qualifiedPool;
                        }
                        if (hirePool.length > 0) {
                            hirePool.sort((a,b) => b.age - a.age); 
                            candidate = hirePool[0];
                        }
                    }
                    if(candidate) {
                        if(isPromotion) {
                            logEvent(`⬆️ ${candidate.firstName} ${candidate.lastName} a été promu(e) au poste de ${vacantJob.role} depuis ${promotionSource} à ${city.name}.`, city.id, candidate.familyId, { personId: candidate.id }); // MODIFICATION
                        } else {
                            logEvent(`💼 ${candidate.firstName} ${candidate.lastName} a été embauché(e) comme ${vacantJob.role} à ${city.name}.`, city.id, candidate.familyId, { personId: candidate.id }); // MODIFICATION
                        }
                        const oldJob = candidate.job;
                        if(oldJob) {
                            oldJob.endDate = simulation.year;
                            candidate.jobHistory.push(oldJob);
                        }
                        candidate.job = { ...vacantJob, startDate: simulation.year }; 
                        if(!isPromotion) {
                           availableCandidates = availableCandidates.filter(p => p.id !== candidate.id);
                        }
                    }
                });
                let unemployedAdults = availableCandidates.filter(p => p.age >= (simulation.races[p.race]?.adultAge || 18));
                const cityStatus = city.config.city_status;
                const beggarJob = jobData.autonomous_jobs.find(j => j.isBeggar);
                if (beggarJob && (cityStatus === 'difficulte' || cityStatus === 'declin')) {
                    const BEGGAR_CHANCES = { 'difficulte': 0.03, 'declin': 0.07 };
                    const chance = BEGGAR_CHANCES[cityStatus] || 0;
                    if (chance > 0) {
                        unemployedAdults.forEach(person => {
                            if(!person.job && Math.random() < chance) {
                                person.job = {...beggarJob, startDate: simulation.year};
                                logEvent(`🙏 ${person.firstName} ${person.lastName} est devenu mendiant à ${city.name}.`, city.id, person.familyId, { personId: person.id }); // MODIFICATION
                            }
                        });
                        unemployedAdults = unemployedAdults.filter(p => !p.job);
                    }
                }
                const autonomousJobs = jobData.autonomous_jobs.filter(j => !j.isBeggar && !j.isUnderworld);
                unemployedAdults.forEach(person => {
                    if (Math.random() < 0.25) {
                        const jobPool = Math.random() < 0.8 ? autonomousJobs.filter(j => j.tier === 4) : autonomousJobs.filter(j => j.tier === 3);
                        if (jobPool.length > 0) {
                            person.job = {...jobPool[Math.floor(Math.random() * jobPool.length)], startDate: simulation.year};
                        }
                    }
                });
            });
        }

        function degradeCityStatus(city, severity = 1) {
            const progressionArray = ['prospere', 'stable', 'difficulte', 'declin'];
            const progressionMap = { 'prospere': 0, 'stable': 1, 'difficulte': 2, 'declin': 3 };
            const oldStatus = city.config.city_status || 'stable';
            const currentIndex = progressionMap[oldStatus];
            if(currentIndex === undefined) return;
            const newIndex = Math.min(progressionArray.length - 1, currentIndex + severity);
            const newStatus = progressionArray[newIndex];
            if (oldStatus !== newStatus) {
                city.config.city_status = newStatus;
                logEvent(`📉 À cause d'un afflux soudain de population, le statut de <strong>${city.name}</strong> s'est ${severity > 1 ? 'sévèrement ' : ''}dégradé de '${oldStatus}' à '${newStatus}'.`, city.id, null);
            }
        }

        function processMigrationImpact() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;
            const MIGRATION_IMPACT_THRESHOLD = 1;
            const beggarJob = jobData.autonomous_jobs.find(j => j.isBeggar);
            currentRegion.cities.forEach(city => {
                const cityPopulation = simulation.population.filter(p => p.isAlive && p.cityId === city.id).length;
                if (cityPopulation === 0) return;
                const opportunityMigrantsEvents = simulation.eventLog.filter(e => e.year === simulation.year && e.cityId === city.id && e.message.includes("En quête d'opportunités") && e.meta && e.meta.personId);
                const migrantCount = opportunityMigrantsEvents.length;
                if (migrantCount === 0) return;
                const migrationPercentage = (migrantCount / (cityPopulation - migrantCount)) * 100;
                if (migrationPercentage > MIGRATION_IMPACT_THRESHOLD) {
                    let severity = 1;
                    if (migrationPercentage > 3) {
                        severity = 2;
                    }
                    degradeCityStatus(city, severity);
                    if (beggarJob) {
                        opportunityMigrantsEvents.forEach(event => {
                            const migrant = simulation.population.find(p => p.id === event.meta.personId);
                            if (migrant && migrant.isAlive && !migrant.job) {
                                migrant.job = { ...beggarJob, startDate: simulation.year };
                                logEvent(`🙏 Arrivé sans ressources, ${migrant.firstName} ${migrant.lastName} est devenu mendiant à ${city.name}.`, city.id, migrant.familyId, { personId: migrant.id });
                            }
                        });
                    }
                }
            });
        }

        function handleDeaths() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;
            simulation.population.forEach(person => {
                if (!person.isAlive) return;
                const raceInfo = simulation.races[person.race];
                if (!raceInfo) return;
                let died = false;
                let deathChance = 0;
                if (person.age > raceInfo.lifespan) {
                    deathChance = (person.age - raceInfo.lifespan) / 15;
                } else if (person.age > raceInfo.lifespan * 0.9) {
                    deathChance = 0.005;
                }
                if (Math.random() < deathChance) {
                    logEvent(`🕊️ ${person.firstName} ${person.lastName} (${person.job?.role || 'Sans emploi'}) est décédé(e) de vieillesse à ${person.age} ans à ${person.cityName}.`, person.cityId, person.familyId, { personId: person.id });
                    died = true;
                }
                if (!died && person.age > 16 && person.age < (raceInfo.lifespan * 0.85)) {
                    const city = currentRegion.cities.find(c => c.id === person.cityId);
                    const cityStatus = city?.config?.city_status || 'stable';
                    let diedPrematurely = false;
                    let causeOfDeathMessage = '';
                    const crimeDeathCauses = ["tué(e) lors d'un vol", "victime d'une agression de rue", "assassiné(e) par un rival", "pris(e) dans un règlement de comptes"];
                    const famineDeathCauses = ["mort(e) de faim", "mort(e) de malnutrition due à la famine", "décédé(e) des suites de la disette"];
                    const genericPrematureDeathCauses = ["d'une maladie soudaine", "d'un accident de travail", "d'une rixe qui a mal tourné", "en protégeant un proche", "d'une chute malencontreuse", "des mauvaises conditions de vie", "d'une épidémie locale"];
                    const statusDeathRates = { 'prospere': { generic: 0.0010, crime: 0.0000, famine: 0.0000 }, 'stable': { generic: 0.0015, crime: 0.0001, famine: 0.0000 }, 'difficulte': { generic: 0.0020, crime: 0.0015, famine: 0.0005 }, 'declin': { generic: 0.0025, crime: 0.0035, famine: 0.0025 } };
                    const rates = statusDeathRates[cityStatus] || statusDeathRates['stable'];
                    let finalRates = { ...rates };
                    let riskMultiplier = 1.0;
                    if (person.yearsSinceMigration !== undefined && person.yearsSinceMigration < 5) {
                        riskMultiplier = 2.5; 
                    } else if (!person.job || person.job.isBeggar) {
                        riskMultiplier = 2.0; 
                    }
                    finalRates.crime *= riskMultiplier;
                    finalRates.famine *= riskMultiplier;
                    finalRates.generic *= (riskMultiplier > 1.0 ? 1.2 : 1.0);
                    if (Math.random() < finalRates.famine) {
                        diedPrematurely = true;
                        const cause = famineDeathCauses[Math.floor(Math.random() * famineDeathCauses.length)];
                        causeOfDeathMessage = `💀 ${person.firstName} ${person.lastName} est ${cause} à ${person.age} ans, victime de la famine qui frappe ${person.cityName}.`;
                    } else if (Math.random() < finalRates.crime) {
                        diedPrematurely = true;
                        const cause = crimeDeathCauses[Math.floor(Math.random() * crimeDeathCauses.length)];
                        causeOfDeathMessage = `💀 ${person.firstName} ${person.lastName} a été ${cause} à ${person.age} ans, victime de l'insécurité à ${person.cityName}.`;
                    } else if (Math.random() < finalRates.generic) {
                        diedPrematurely = true;
                        const cause = genericPrematureDeathCauses[Math.floor(Math.random() * genericPrematureDeathCauses.length)];
                        causeOfDeathMessage = `💀 ${person.firstName} ${person.lastName} est décédé(e) prématurément à ${person.age} ans ${cause} à ${person.cityName}.`;
                    }
                    if (diedPrematurely) {
                        logEvent(causeOfDeathMessage, person.cityId, person.familyId, { personId: person.id });
                        died = true;
                    }
                }
                if (died) {
                    if (person.job) {
                        person.job.endDate = simulation.year;
                        person.jobHistory.push(person.job);
                    }
                    person.isAlive = false;
                    person.job = null;
                    if (person.spouseId !== null) {
                        const spouse = simulation.population.find(p => p.id === person.spouseId);
                        if (spouse && spouse.isAlive) {
                            spouse.spouseId = null;
                            // --- MODIFICATION POUR LE REMARIAGE ---
                            spouse.widowedInYear = simulation.year;
                            if (spouse.marriageStartDate !== null) {
                                spouse.lastMarriageDuration = simulation.year - spouse.marriageStartDate;
                            }
                            spouse.marriageStartDate = null;
                        }
                    }
                }
            });
        }
        
        function checkForFamilyExtinction() {
            for (const familyId in simulation.families) {
                const family = simulation.families[familyId];
                if (!family || !family.members || family.isExtinct) continue;
                const members = family.members.map(id => simulation.population.find(p => p.id === id)).filter(Boolean);
                const hasLivingMaleHeir = members.some(p => p.isAlive && p.gender === 'M' && p.lastName === family.originalName);
                if (!hasLivingMaleHeir) {
                    const region = getCurrentRegion();
                    const city = region.cities.find(c => c.name === family.location);
                    const cityId = city ? city.id : null;
                    let message = `☠️ La lignée des <strong>${family.originalName}</strong> dans <strong>${family.location}</strong> s'est éteinte, n'ayant plus d'héritier mâle.`;
                    const allPeopleWithFamilyName = simulation.population.filter(p => p.isAlive && (p.lastName === family.originalName || p.maidenName === family.originalName));
                    const otherCities = [...new Set(allPeopleWithFamilyName.map(p => p.cityName).filter(cityName => cityName !== family.location))];
                    if (otherCities.length > 0) {
                        message += ` Mais reste de la famille dans le ou les lieux "${otherCities.join('", "')}".`;
                    }
                    logEvent(message, cityId, familyId);
                    family.isExtinct = true;
                }
            }
        }

        function handleBirths() {
            const newChildren = [];
            const couples = simulation.population.filter(p => p.isAlive && p.gender === 'M' && p.spouseId !== null);
            couples.forEach(father => {
                const mother = simulation.population.find(p => p.id === father.spouseId);
                if (!mother || !mother.isAlive) return;
                const raceInfo = simulation.races[mother.race];
                if (!raceInfo) return;
                const fertilityEndAge = raceInfo.lifespan * 0.55;
                if (mother.age >= raceInfo.adultAge && mother.age < fertilityEndAge) {
                    const maxFertilityChance = 0.20; 
                    const fertilityRange = fertilityEndAge - raceInfo.adultAge;
                    const yearsIntoFertility = mother.age - raceInfo.adultAge;
                    const fertilityProgress = yearsIntoFertility / fertilityRange;
                    const currentBirthChance = maxFertilityChance * (1 - fertilityProgress);
                    if(Math.random() < currentBirthChance) {
                        const childAge = 0;
                        const childRace = Math.random() < 0.5 ? father.race : mother.race;
                        const childGender = Math.random() < 0.5 ? 'M' : 'F';
                        const child = createPerson(childRace, father.lastName, father.familyId, childGender, childAge, father.cityId, father.cityName, [father.id, mother.id]);
                        if(child){
                            father.children.push(child.id);
                            mother.children.push(child.id);
                            if (simulation.families[child.familyId]) {
                                simulation.families[child.familyId].members.push(child.id);
                            }
                            newChildren.push(child);
                            logEvent(`👶 Un enfant, ${child.firstName}, est né dans la famille ${father.lastName}.`, father.cityId, father.familyId, { personId: child.id });
                        }
                    }
                }
            });
            simulation.population.push(...newChildren);
        }

        function isSeekingMarriage(person) {
            // S'il n'est pas veuf, il est toujours prêt (s'il est célibataire)
            if (person.widowedInYear === null) {
                return true;
            }

            const yearsSinceWidowed = simulation.year - person.widowedInYear;

            // Période de deuil stricte de 2 ans
            if (yearsSinceWidowed < 2) {
                return false;
            }

            const raceInfo = simulation.races[person.race];
            if (!raceInfo) return false;

            // Facteur lié à l'âge : les chances diminuent avec l'âge
            const ageFactor = Math.max(0, 1 - (person.age / (raceInfo.lifespan * 0.9)));

            // Facteur lié à la durée du mariage précédent : un mariage long rend plus difficile de passer à autre chose
            const durationFactor = person.lastMarriageDuration ? Math.max(0.1, 1 - (person.lastMarriageDuration / 40)) : 1;

            // Facteur lié temps : plus le temps passe, plus on est susceptible de chercher à nouveau
            const timeFactor = Math.min(1, (yearsSinceWidowed - 1) / 5); // Atteint 100% après 5 ans post-deuil

            // Chance de base de chercher un partenaire cette année
            const chanceToSeekPartner = 0.8 * ageFactor * durationFactor * timeFactor;

            return Math.random() < chanceToSeekPartner;
        }
        
        function handleMarriages() {
            const FOREIGN_MARRIAGE_CHANCE = 0.25; 
            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;

            // Filtre les célibataires qui sont activement à la recherche d'un partenaire cette année
            const singleMen = simulation.population.filter(p => 
                p.isAlive && 
                p.spouseId === null && 
                p.gender === 'M' && 
                p.age >= (simulation.races[p.race]?.adultAge || 18) &&
                isSeekingMarriage(p)
            );
            
            let singleWomen = simulation.population.filter(p => 
                p.isAlive && 
                p.spouseId === null && 
                p.gender === 'F' && 
                p.age >= (simulation.races[p.race]?.adultAge || 18)
            );

            singleMen.forEach(man => {
                if (man.spouseId) return; // Vérification double, au cas où il se marie dans la même boucle

                const filterConditions = woman => {
                    if (woman.spouseId || woman.familyId === man.familyId) return false;
                    if (!isSeekingMarriage(woman)) return false; // La femme doit aussi être en recherche
                    return Math.abs(man.age - woman.age) <= 5;
                };

                let suitableWives = singleWomen.filter(woman => woman.cityId === man.cityId && filterConditions(woman));
                
                if (suitableWives.length === 0 && Math.random() < FOREIGN_MARRIAGE_CHANCE) {
                    const manCity = currentRegion.cities.find(c => c.id === man.cityId);
                    if (!manCity) return;
                    const influenceToRadius = { 'local': 1, 'grand': 3, 'regional': 100 };
                    const manInfluence = influenceToRadius[manCity.config?.market_influence] || 1;
                    suitableWives = singleWomen.filter(woman => {
                        if (woman.cityId === man.cityId || !filterConditions(woman)) return false;
                        const womanCity = currentRegion.cities.find(c => c.id === woman.cityId);
                        if (!womanCity) return false;
                        const womanInfluence = influenceToRadius[womanCity.config?.market_influence] || 1;
                        const distInHexes = cubeDistance(offsetToCube(manCity.q, manCity.r), offsetToCube(womanCity.q, womanCity.r));
                        return distInHexes <= manInfluence || distInHexes <= womanInfluence;
                    });
                }

                if (suitableWives.length > 0) {
                    const woman = suitableWives[Math.floor(Math.random() * suitableWives.length)];
                    
                    if (!woman.maidenName) {
                        woman.maidenName = woman.lastName;
                    }
                    const oldFamilyId = woman.familyId;
                    
                    man.spouseId = woman.id;
                    woman.spouseId = man.id;
                    man.marriages = (man.marriages || 0) + 1;
                    woman.marriages = (woman.marriages || 0) + 1;
                    woman.lastName = man.lastName;
                    
                    // --- MODIFICATION POUR LE REMARIAGE ---
                    man.marriageStartDate = simulation.year;
                    woman.marriageStartDate = simulation.year;
                    man.widowedInYear = null;
                    woman.widowedInYear = null;

                    // NOUVEAU : Si l'un des deux est mendiant et l'autre non, il/elle est "sauvé(e)" par le mariage.
                    if (woman.job?.isBeggar && man.job && !man.job.isBeggar && !man.job.isUnderworld) {
                        logEvent(`💖 Grâce à son mariage, ${woman.firstName} ${woman.lastName} n'est plus mendiante.`, woman.cityId, woman.familyId, { personId: woman.id });
                        woman.job = null;
                        woman.yearsAsBeggar = 0;
                        woman.yearsUnemployed = 0;
                    } else if (man.job?.isBeggar && woman.job && !woman.job.isBeggar && !woman.job.isUnderworld) {
                        logEvent(`💖 Grâce à son mariage, ${man.firstName} ${man.lastName} n'est plus mendiant.`, man.cityId, man.familyId, { personId: man.id });
                        man.job = null;
                        man.yearsAsBeggar = 0;
                        man.yearsUnemployed = 0;
                    }

                    let marriageLog = `⚭ ${man.firstName} ${man.lastName} et ${woman.firstName} ${woman.lastName} (née ${woman.maidenName}) se sont mariés.`;
                    
                    const manMarriageRank = getOrdinal(man.marriages);
                    const womanMarriageRank = getOrdinal(woman.marriages);

                    if (man.marriages > 1 || woman.marriages > 1) {
                         const remarks = [];
                         if (man.marriages > 1) remarks.push(`il s'agit du ${manMarriageRank} mariage pour l'époux`);
                         if (woman.marriages > 1) remarks.push(`il s'agit du ${womanMarriageRank} mariage pour l'épouse`);
                         marriageLog += ` (${remarks.join(' et ')}).`;
                    }
                    
                    const eventMeta = { person1Id: man.id, person2Id: woman.id };
                    logEvent(marriageLog, woman.cityId, man.familyId, eventMeta);
                    logEvent(marriageLog, woman.cityId, oldFamilyId, eventMeta);
                    
                    const newFamilyId = man.familyId;
                    if (oldFamilyId !== newFamilyId) {
                        woman.familyId = newFamilyId;
                        if (simulation.families[oldFamilyId]) {
                            simulation.families[oldFamilyId].members = simulation.families[oldFamilyId].members.filter(id => id !== woman.id);
                        }
                        if (simulation.families[newFamilyId]) {
                            simulation.families[newFamilyId].members.push(woman.id);
                        }
                    }
                    if (man.cityId !== woman.cityId) {
                        handleRelocation(man, woman, { type: 'marriage' });
                    }
                    singleWomen = singleWomen.filter(w => w.id !== woman.id);
                }
            });
        }
        
        function handleRelocation(person1, person2, reason) {
            let personToMove, targetCity, logMessage;
            
            const oldCityName = (reason.type === 'marriage' ? person1.cityName : person1.cityName); // Temporaire
            const personToMoveRef = (reason.type === 'marriage') ? person1 : person1; // Juste pour get le nom
            
            if (reason.type === 'marriage') {
                const cityTiers = { 'Capitale': 1, 'Ville': 2, 'Village': 3, 'Hameau': 4, 'Donjon': 5 };
                const person1JobTier = person1.job?.tier || 99;
                const person2JobTier = person2.job?.tier || 99;
                const person1City = getCurrentRegion().cities.find(c=>c.id === person1.cityId);
                const person2City = getCurrentRegion().cities.find(c=>c.id === person2.cityId);
                if (!person1City || !person2City) return;
                const person1CityTier = cityTiers[person1City.type] || 99;
                const person2CityTier = cityTiers[person2City.type] || 99;
                if (person1JobTier < person2JobTier - 1) { personToMove = person2; targetCity = person1City; } 
                else if (person2JobTier < person1JobTier - 1) { personToMove = person1; targetCity = person2City; } 
                else if (person1CityTier < person2CityTier) { personToMove = person2; targetCity = person1City; } 
                else { personToMove = person1; targetCity = person2City; }

                const oldJob = personToMove.job;
                if (oldJob) {
                    oldJob.endDate = simulation.year;
                    personToMove.jobHistory.push(oldJob);
                }
                personToMove.job = null; // Devient sans emploi
                const oldJobText = oldJob ? `quittant son poste de ${oldJob.role}` : 'qui était sans emploi';
                const spouse = (personToMove.id === person1.id) ? person2 : person1;
                logMessage = `✈️ Pour rejoindre son/sa conjoint(e) ${spouse.firstName} ${spouse.lastName}, ${personToMove.firstName} ${personToMove.lastName} a déménagé de ${personToMove.cityName} à ${targetCity.name}, ${oldJobText}.`;

            } else if (reason.type === 'opportunity') {
                personToMove = person1;
                targetCity = reason.destinationCity;
                personToMove.yearsSinceMigration = 0;
                
                const oldJob = personToMove.job;
                if (oldJob) {
                    oldJob.endDate = simulation.year;
                    personToMove.jobHistory.push(oldJob);
                    personToMove.job = null; // Devient sans emploi
                    logMessage = `✨ En quête d'opportunités, ${personToMove.firstName} ${personToMove.lastName} a déménagé de ${personToMove.cityName} à ${targetCity.name}, quittant son poste de ${oldJob.role} et arrivant sans emploi.`;
                } else {
                    const beggarJob = jobData.autonomous_jobs.find(j => j.isBeggar);
                    if (beggarJob) {
                        personToMove.job = { ...beggarJob, startDate: simulation.year }; // Devient mendiant
                        logMessage = `✨ En quête d'opportunités, ${personToMove.firstName} ${personToMove.lastName} a déménagé de ${personToMove.cityName} à ${targetCity.name}, arrivant sans ressources et devenant mendiant(e).`;
                    } else {
                        personToMove.job = null; // Failsafe
                        logMessage = `✨ En quête d'opportunités, ${personToMove.firstName} ${personToMove.lastName} a déménagé de ${personToMove.cityName} à ${targetCity.name} et est maintenant sans emploi.`;
                    }
                }
            } else {
                return;
            }

            personToMove.cityId = targetCity.id;
            personToMove.cityName = targetCity.name;

            if (personToMove.gender === 'M' && simulation.families[personToMove.familyId]) {
                simulation.families[personToMove.familyId].location = targetCity.name;
            }
            
            const eventMeta = { personId: personToMove.id };
            logEvent(logMessage, targetCity.id, personToMove.familyId, eventMeta);
        }

        function handleEconomicMigration() {
            const currentRegion = getCurrentRegion();
            if (!currentRegion) return;
            const cityScores = {};
            currentRegion.cities.forEach(city => {
                const statusMultipliers = { 'prospere': 1.5, 'stable': 1.0, 'difficulte': 0.7, 'declin': 0.4 };
                const marketMultipliers = { 'regional': 1.3, 'grand': 1.1, 'local': 1.0 };
                let score = 1.0;
                score *= statusMultipliers[city.config?.city_status] || 1.0;
                score *= marketMultipliers[city.config?.market_influence] || 1.0;
                const filledJobs = {};
                simulation.population.forEach(p => {
                    if (p.isAlive && p.job && p.cityId === city.id) {
                        filledJobs[p.job.role] = (filledJobs[p.job.role] || 0) + 1;
                    }
                });
                let vacantHighTierJobs = 0;
                const requiredJobs = [...(jobData.base_jobs[city.type] || []), ...(Object.values(jobData.building_jobs).flat())];
                requiredJobs.forEach(jobInfo => {
                    if (jobInfo.tier <= 2) {
                        const needed = (jobInfo.quantity || 1) - (filledJobs[jobInfo.role] || 0);
                        if (needed > 0) vacantHighTierJobs += needed;
                    }
                });
                score += vacantHighTierJobs * 0.25;
                cityScores[city.id] = { score: score, city: city };
            });
            const potentialMigrants = simulation.population.filter(p => {
                const raceInfo = simulation.races[p.race];
                return p.isAlive && raceInfo && p.age > raceInfo.adultAge && (!p.job || (p.job.tier && p.job.tier >= 4));
            });
            potentialMigrants.forEach(person => {
                const personCity = currentRegion.cities.find(c => c.id === person.cityId);
                if (!personCity) return;
                const personCityStatus = personCity.config?.city_status || 'stable';
                const MIGRATION_CHECK_CHANCES = { 'prospere': 0.005, 'stable':   0.01, 'difficulte': 0.04, 'declin':   0.08 };
                if (Math.random() < (MIGRATION_CHECK_CHANCES[personCityStatus] || 0.01)) {
                    const currentCityScore = cityScores[person.cityId]?.score || 0;
                    let bestAlternative = null;
                    for (const cityId in cityScores) {
                        if (cityId !== person.cityId) {
                            const destinationCity = cityScores[cityId].city;
                            const kmPerHex = getCurrentRegion()?.hexDistance || 10;
                            const distInHexes = cubeDistance(offsetToCube(personCity.q, personCity.r), offsetToCube(destinationCity.q, destinationCity.r));
                            const distInKm = distInHexes * kmPerHex;
                            const perceivedScore = cityScores[cityId].score * (1 - (distInKm * 0.02));
                            if (perceivedScore > currentCityScore * 1.2) { 
                                if (!bestAlternative || perceivedScore > bestAlternative.score) {
                                    bestAlternative = {score: perceivedScore, city: destinationCity};
                                }
                            }
                        }
                    }
                    if (bestAlternative) {
                        const chance = (bestAlternative.score - currentCityScore) / bestAlternative.score;
                        if (Math.random() < chance) {
                            handleRelocation(person, null, { type: 'opportunity', destinationCity: bestAlternative.city });
                        }
                    }
                }
            });
        }
        
        function displayPopulation() {
            const popDisplay = document.getElementById('population-display');
            if (!popDisplay) return;
            const activeMainTab = popDisplay.querySelector(':scope > .tab-nav > .tab-button.active');
            const activeMainTabId = activeMainTab ? activeMainTab.dataset.tabId : 'population';
            let activeSubTabCityId = null;
            if (activeMainTab) {
                const activeMainPanelId = `tab-panel-${activeMainTabId}`;
                const activeMainPanel = document.getElementById(activeMainPanelId);
                if (activeMainPanel) {
                    const activeSubTab = activeMainPanel.querySelector('.tab-nav .tab-button.active');
                    if (activeSubTab) {
                        activeSubTabCityId = activeSubTab.dataset.cityId;
                    }
                }
            }
            const modalTitle = document.getElementById('population-modal-title');
            const historyContent = document.getElementById('history-log-content');
            const tabNav = popDisplay.querySelector(':scope > .tab-nav');
            const tabPanels = popDisplay.querySelector(':scope > .tab-panels');
            if (!modalTitle || !historyContent || !tabNav || !tabPanels) return;
            tabNav.innerHTML = '';
            tabPanels.innerHTML = '';
            const totalPopulation = simulation.population.filter(p => p.isAlive).length;
            modalTitle.textContent = `Population de la Région (Année ${simulation.year}) - ${totalPopulation} habitants`;
            historyContent.innerHTML = simulation.eventLog
                .slice().reverse().map(entry => `<p>${entry.message}</p>`).join('');
            historyContent.scrollTop = 0;
            const currentRegion = getCurrentRegion();
            if (!currentRegion || !currentRegion.cities) return;
            const citiesData = [...currentRegion.cities];
            const mainTabs = [{id: 'population', text: 'Population'}, {id: 'evolution', text: 'Évolution du Lieu'}];
            mainTabs.forEach(mainTab => {
                 const tabButton = document.createElement('button');
                 tabButton.className = 'tab-button';
                 tabButton.dataset.tabId = mainTab.id;
                 tabButton.textContent = mainTab.text;
                 tabNav.appendChild(tabButton);
                 const tabPanel = document.createElement('div');
                 tabPanel.className = 'tab-panel';
                 tabPanel.id = `tab-panel-${mainTab.id}`;
                 tabPanel.innerHTML = `<div class="tab-nav"></div><div class="tab-panels"></div>`;
                 tabPanels.appendChild(tabPanel);
                 tabButton.addEventListener('click', () => {
                    popDisplay.querySelectorAll(':scope > .tab-nav > .tab-button').forEach(btn => btn.classList.remove('active'));
                    popDisplay.querySelectorAll(':scope > .tab-panels > .tab-panel').forEach(panel => panel.classList.remove('active'));
                    tabButton.classList.add('active');
                    tabPanel.classList.add('active');
                 });
            });
            citiesData.sort((a, b) => a.name.localeCompare(b.name)).forEach(cityData => {
                const cityPopulationCount = simulation.population.filter(p => p.isAlive && p.cityId === cityData.id).length;
                const popTabPanel = document.getElementById('tab-panel-population');
                const popSubTabNav = popTabPanel.querySelector('.tab-nav');
                const popSubTabPanels = popTabPanel.querySelector('.tab-panels');
                const popSubTabBtn = document.createElement('button');
                popSubTabBtn.className = 'tab-button';
                popSubTabBtn.dataset.cityId = cityData.id;
                popSubTabBtn.textContent = `${cityData.name} (${cityPopulationCount} hab.)`;
                popSubTabNav.appendChild(popSubTabBtn);
                const popSubTabPanel = document.createElement('div');
                popSubTabPanel.className = 'tab-panel';
                popSubTabPanel.id = `pop-subpanel-${cityData.id}`;
                popSubTabPanel.innerHTML = `<div class="tab-panel-content">${generateCityPopulationHtml(cityData)}</div>`;
                popSubTabPanels.appendChild(popSubTabPanel);
                popSubTabBtn.addEventListener('click', () => {
                    popSubTabNav.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    popSubTabPanels.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
                    popSubTabBtn.classList.add('active');
                    popSubTabPanel.classList.add('active');
                });
                const evoTabPanel = document.getElementById('tab-panel-evolution');
                const evoSubTabNav = evoTabPanel.querySelector('.tab-nav');
                const evoSubTabPanels = evoTabPanel.querySelector('.tab-panels');
                const evoSubTabBtn = document.createElement('button');
                evoSubTabBtn.className = 'tab-button';
                evoSubTabBtn.dataset.cityId = cityData.id;
                evoSubTabBtn.textContent = `${cityData.name}`;
                evoSubTabNav.appendChild(evoSubTabBtn);
                const evoSubTabPanel = document.createElement('div');
                evoSubTabPanel.className = 'tab-panel';
                evoSubTabPanel.id = `evo-subpanel-${cityData.id}`;
                evoSubTabPanel.innerHTML = `<div class="tab-panel-content">${generateCityEvolutionHtml(cityData)}</div>`;
                evoSubTabPanels.appendChild(evoSubTabPanel);
                evoSubTabBtn.addEventListener('click', () => {
                    evoSubTabNav.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    evoSubTabPanels.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
                    evoSubTabBtn.classList.add('active');
                    evoSubTabPanel.classList.add('active');
                });
            });
            const mainTabToActivate = tabNav.querySelector(`[data-tab-id="${activeMainTabId}"]`) || tabNav.firstChild;
            if (mainTabToActivate) {
                mainTabToActivate.click();
                const mainPanelId = `tab-panel-${mainTabToActivate.dataset.tabId}`;
                const subTabContainer = document.getElementById(mainPanelId);
                if (subTabContainer) {
                    const subTabNav = subTabContainer.querySelector('.tab-nav');
                    if (subTabNav) {
                        const cityIdToActivate = activeSubTabCityId || (citiesData[0] ? citiesData[0].id : null);
                        const subTabToActivate = subTabNav.querySelector(`[data-city-id="${cityIdToActivate}"]`) || subTabNav.querySelector('.tab-button');
                        if (subTabToActivate) {
                            subTabToActivate.click();
                        }
                    }
                }
            }
            populationModal.style.display = 'flex';
            const eventLog = simulation.eventLog;
            const birthCount = eventLog.filter(e => e.message.startsWith('👶')).length;
            const deathCount = eventLog.filter(e => e.message.startsWith('🕊️') || e.message.startsWith('💀')).length;
            const marriageCount = eventLog.filter(e => e.message.startsWith('⚭')).length;
            const marriageMigrationCount = eventLog.filter(e => e.message.startsWith('✈️')).length;
            const opportunityMigrationCount = eventLog.filter(e => e.message.includes("En quête d'opportunités")).length;
            const totalMigrationCount = marriageMigrationCount + opportunityMigrationCount;
            statsBirthsEl.textContent = `Naissances : ${birthCount}`;
            statsDeathsEl.textContent = `Décès : ${deathCount}`;
            statsMarriagesEl.textContent = `Mariages : ${marriageCount}`;
            statsMigrationsEl.textContent = `Migrations : ${totalMigrationCount}`;
            statsMigMarriageEl.textContent = `↳ par mariage : ${marriageMigrationCount}`;
            statsMigOpportunityEl.textContent = `↳ par opportunité : ${opportunityMigrationCount}`;
        }

        function generateCityEvolutionHtml(cityData) {
            let html = '';
            const cityHistoryEvents = simulation.eventLog
                .filter(e => e.cityId === cityData.id && (e.message.startsWith('📈') || e.message.startsWith('📉') || e.message.startsWith('🏛️') || e.message.startsWith('⚖️')))
                .slice()
                .reverse();

            const cityConf = cityData.config || {};
            html += `<p><strong>Statut Actuel :</strong> ${cityConf.city_status || 'N/A'}</p>`;
            html += `<p><strong>Influence du Marché :</strong> ${cityConf.market_influence || 'N/A'}</p>`;

            if (cityHistoryEvents.length > 0) {
                html += `<details open><summary>Historique des infrastructures et du statut</summary><div class="family-history"><ul>`;
                cityHistoryEvents.forEach(event => {
                    html += `<li><strong>Année ${event.year}:</strong> ${event.message}</li>`;
                });
                html += `</ul></div></details>`;
            }
            html += `<h3>Bâtiments et Emplois à ${cityData.name}</h3>`;
            const jobStatus = getCityJobStatus(cityData);
            jobStatus.buildings.forEach(building => {
                html += `<div class="evolution-section"><h5>${building.name}</h5><ul>`;
                building.jobs.forEach(job => {
                    html += `<li><span class="job-name">${job.role}</span> <span class="job-count">${job.filled} / ${job.required}</span></li>`;
                });
                html += `</ul></div>`;
            });
            if (jobStatus.guilds.length > 0) {
                 html += `<h3>Guildes</h3>`;
                 jobStatus.guilds.forEach(guild => {
                     html += `<div class="evolution-section"><h5>${guild.name}</h5><ul>`;
                    guild.jobs.forEach(job => {
                        html += `<li><span class="job-name">${job.role}</span> <span class="job-count">${job.filled} / ${job.required}</span></li>`;
                    });
                    html += `</ul></div>`;
                 });
            }
            html += `<div class="evolution-section"><h5>Métiers Autonomes</h5><ul>`;
            jobStatus.autonomous.forEach(job => {
                 html += `<li><span class="job-name">${job.role}</span> <span class="job-count">${job.filled}</span></li>`;
            });
            html += `</ul></div>`;
            return html;
        }

        function generateCityPopulationHtml(cityData) {
            let cityHtml = '';
            const familiesInCity = Object.values(simulation.families).filter(family => {
                const familyId = Object.keys(simulation.families).find(id => simulation.families[id] === family);
                return simulation.population.some(p => p.familyId === familyId && p.cityId === cityData.id);
            });
            familiesInCity.sort((a,b) => a.originalName.localeCompare(b.originalName)).forEach(familyGroup => {
                const familyId = Object.keys(simulation.families).find(id => simulation.families[id] === familyGroup);
                const familyName = familyGroup.originalName;
                const familyMembersInCity = simulation.population.filter(p => p.familyId === familyId && p.cityId === cityData.id);
                const hasLivingMembers = familyMembersInCity.some(p => p.isAlive);
                const familyHistory = simulation.eventLog.filter(e => e.familyId === familyId);
                const validEvents = familyHistory.slice().reverse().filter(e => e.message.replace(/<\/?h3>/g, '').trim());
                if (hasLivingMembers) {
                    cityHtml += `<details open><summary>${familyName} ${familyGroup.isExtinct ? '(Lignée éteinte)' : ''}</summary>`;
                    if (validEvents.length > 0) {
                        const previewHtml = validEvents.slice(0, 3).map(event => {
                            const message = event.message.replace(/<\/?h3>/g, '').trim();
                            return `<li><strong>Année ${event.year}:</strong> ${message}</li>`;
                        }).join('');
                        const openModalButton = validEvents.length > 3 ? `<button class="open-history-modal-btn" data-family-id="${familyId}" data-family-name="${familyName}">Afficher tout l'historique (${validEvents.length} événements)</button>` : '';
                        cityHtml += `<div class="family-history"><h5>Historique (récent)</h5><div><ul>${previewHtml}</ul></div>${openModalButton}</div>`;
                    }
                    const membersMap = new Map(familyMembersInCity.map(p => [p.id, p]));
                    const roots = familyMembersInCity.filter(p => (!p.parents || p.parents.length === 0 || !p.parents.some(parentId => membersMap.has(parentId))));
                    const renderedIds = new Set();
                    cityHtml += `<div class="family-tree"><ul>`;
                    roots.sort((a, b) => b.age - a.age).forEach(root => {
                         if (!renderedIds.has(root.id)) {
                            cityHtml += renderFamilyTree(root, membersMap, renderedIds);
                         }
                    });
                    cityHtml += `</ul></div></details>`;
                }
            });
            const movedAwayFamilies = [];
            for (const familyId in simulation.families) {
                const family = simulation.families[familyId];
                if (family.location !== cityData.name && !family.isExtinct) {
                    const hasHistoryInCity = simulation.eventLog.some(e => e.familyId === familyId && e.cityId === cityData.id);
                    if (hasHistoryInCity) {
                        movedAwayFamilies.push(family);
                    }
                }
            }
            movedAwayFamilies.sort((a,b) => a.originalName.localeCompare(b.originalName)).forEach(family => {
                cityHtml += `<details><summary>${family.originalName} (Parti)</summary><div class="family-history family-history-moved"><p>La famille ${family.originalName} ne réside plus à ${cityData.name}.<br>Elle se trouve actuellement à : <strong>${family.location}</strong>.</p></div></details>`;
            });
            return cityHtml;
        }

        function renderFamilyTree(person, membersMap, renderedIds) {
            if (!person || renderedIds.has(person.id)) return '';
            renderedIds.add(person.id);
            let html = '<li>';
            const spouse = person.spouseId ? simulation.population.find(p => p.id === person.spouseId) : null;
            html += formatPerson(person);
            if (spouse && spouse.cityId === person.cityId) {
                renderedIds.add(spouse.id);
                html += ' & ' + formatPerson(spouse);
            }
            const childrenIds = new Set(person.children);
            if(spouse) {
                spouse.children.forEach(id => childrenIds.add(id));
            }
            const children = Array.from(childrenIds).map(id => membersMap.get(id)).filter(Boolean).sort((a,b) => b.age - a.age);
            if (children.length > 0) {
                html += '<ul>';
                children.forEach(child => {
                    html += renderFamilyTree(child, membersMap, renderedIds);
                });
                html += '</ul>';
            }
            html += '</li>';
            return html;
        }
        
        // MODIFICATION: Fonction séparée pour le formatage du travail qui calcule et inclut la durée.
        function formatPersonJob(person) {
             if (person.job) {
                if (person.job.isRetired) {
                    return `<span class="person-job retired">${person.job.role}</span>`;
                }
                const duration = Math.max(0, simulation.year - person.job.startDate);
                const yearText = duration > 1 ? 'ans' : 'an';
                return `<span class="person-job">${person.job.role} (depuis an ${person.job.startDate}, ${duration} ${yearText})</span>`;
            } else {
                return person.isAlive ? 'Sans emploi' : '';
            }
        }

        // MODIFICATION: Met à jour l'affichage de l'historique des postes pour inclure la durée.
        function formatPerson(person) {
            const deadClass = person.isAlive ? '' : 'class="dead"';
            let nameDisplay = `<span ${deadClass}><b>${person.firstName} ${person.lastName}</b>`;
            if(person.maidenName) nameDisplay += ` <span class="maiden-name">(née ${person.maidenName})</span>`;
            nameDisplay += '</span>';
            
            let originInfo = '';
            if (person.originCityId && person.originCityId !== person.cityId) {
                originInfo = ` <span class="origin-info">(originaire de ${person.originCityName})</span>`;
            }
            
            const jobInfo = formatPersonJob(person);
            
            let historyInfo = '';
            if (person.jobHistory && person.jobHistory.length > 0) {
                historyInfo += ' <span class="origin-info">(Anciens postes: ';
                historyInfo += person.jobHistory.map(j => {
                    const duration = Math.max(1, j.endDate - j.startDate);
                    const yearText = duration > 1 ? 'ans' : 'an';
                    return `${j.role} [an ${j.startDate} - an ${j.endDate}] (${duration} ${yearText})`;
                }).join(', ');
                historyInfo += ')</span>';
            }
            
            const ageDisplay = person.isAlive ? `${person.age} ans` : `décédé(e) à ${person.age} ans`;

            return `${nameDisplay} (${person.gender}, ${ageDisplay}, ${person.race})${originInfo}${jobInfo ? ' - ' + jobInfo : ''}${historyInfo}`;
        }
        
        initializePage();
    });
    </script>
</body>
</html>